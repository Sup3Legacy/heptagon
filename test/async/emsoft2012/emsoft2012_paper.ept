node sum(x :int) = (y :int)
let
  y = x + (0 fby y)
tel

node period << n :int | n > 0 >> () returns (c :bool)
var cpt, next_cpt :int;
let
  next_cpt = if (cpt = n) then 1 else (cpt + 1);
  cpt = 1 fby next_cpt;
  c = (cpt = 1);
(*%  () = Iostream.printf(" next_cpt : %d\n cpt : %d\n",next_cpt,cpt);*)
tel

unsafe fun fast(x :float) returns (y :float)
let
  y = x +. 1.0;
(*%*)  () = Do.stuff(1);
tel


unsafe fun slow(x :float) returns (y :float)
let
  y = x +. 3.14;
(*%*)  () = Do.stuff(3);
tel


unsafe node slow_fast() returns (y :float)
var big_step :bool; ys, yf :float;
let
  big_step = period<<3>>(); (*% (100) *)
  ys = 0.0 fby slow(y when big_step);
  y = merge big_step (ys) (yf);
  yf = fast ((0.0 fby y) whenot big_step);
   () = Iostream.printf(" big_step : %b\n y : %f\n", big_step, y);
   () = Iostream.printf(" ys : %f\n", ys);
   () = Iostream.printf(" yf : %f\n", yf);
tel

unsafe node a_slow_fast() returns (y :float)
var big_step :bool; ys :future float; yf :float;
let
  big_step = period<<3>>(); (*% (100) *)
  ys = async 0.0 fby async slow(y when big_step);
  y = merge big_step (!ys) (yf);
  yf = fast ((0.0 fby y) whenot big_step);
  () = Iostream.printf(" big_step : %b\n y : %f\n", big_step, y);
  () = Iostream.printf(" yf : %f\n", yf);
tel

node parallel_map<<n :int; val node f(int) = (int);>>
  (x :int^n) = (y :int^n)
var ay :(future int)^n;
let
  ay = map<<n>> (async f) (x);
  y = map<<n>> (!) (ay);
tel

node m_parallel_map() returns (y,y2 :int^2)
let
  y = map<<2>> sum ([1,3]);
  y2 = parallel_map<<2,sum>> ([1,3]);
tel

unsafe node partial_desync_b() = (y:int; c:bool)
var f_y1, f_y2 : int
let
  f_y1 = sum(1);
  f_y2 = sum(2);
  c = false fby false fby true fby c;
  y = (f_y1 when c) + (f_y2 when c);
  () = Iostream.printf(" sum1 : %d\n sum2 : %d\n c : %b\n",f_y1,f_y2,c);
  () = Iostream.printf(" y : %d\n",y);
tel

unsafe node partial_desync() = (y:int; c:bool)
var f_y1, f_y2 : future int
let
  f_y1 = async sum(1);
  f_y2 = async sum(2);
  c = false fby true fby c;
  y = (! f_y1 when c) + (! f_y2 when c);
tel

unsafe node array_data<<val node f(int) = (int);>>
  (x :int) = (y :int) var half :bool;
let
  half = true fby (not half);
  reset y = f(x) every half;
tel

unsafe node array_sum() = (y :int)
let
  y = array_data<<sum>> (0)
tel

unsafe node array_dp<<n, p :int; val node g(int) = (int);>>
  (x :int) = (y :int)
var r :bool; ay :future int;
let
  r = period<<n>>();
  () = Iostream.printf(" r : %b\n",r);
  reset
    ay = async<<n-1,p>> g(x);
  every r;
  y =  !(async 0 fby async 0 fby ay); 

tel

unsafe node m_array_dp() returns (y :int)
var x:int
let
  x = 1 fby (x + 1);
  () = Iostream.printf(" x : %d\n y : %d\n",x,y);
  y = array_dp<<2,2,sum>>(x)
tel
