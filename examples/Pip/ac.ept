
(*
type cell_state = int


(* Takes as input the observable world, and update the new_world at the given position *)
node alternate_cell<<n :int>>(world :cell_state^n; current_cell : cell_state; position :int; ) = (cell : cell_state)
let
  cell = if world[>position<] = 0 then 1 else 0;
tel

node cell3<<n :int; rule :int>>(world : cell_state^n; current_cell : cell_state; position :int;) = (cell : cell_state)
var nb,pos_1,pos1 :int;
let
  pos_1 = if position-1 < 0 then n-1 else position-1;
  pos1 = if position+1 >= n then 0 else position+1;
  nb = (world[>pos_1<] <<< 2) ||| (world[>position<] <<< 1) ||| (world[>pos1<]);
  cell = if bool_of_int(rule &&& (1 <<< nb)) then 1 else 0; (* we need to set true at 1 otherwise the above function is wrong *)
tel

node game<<n :int; val node cell (cell_state^n;cell_state;int) = (cell_state);>>
  (world : cell_state^n; new_world : cell_state^n at r) = (new_world_up : cell_state^n at r)
let
  new_world_up = mapi<<n>> cell <(world)> (new_world)
tel


unsafe node main<<n :int; start : cell_state^n>> () = (ww : cell_state^n;)
var new_world : cell_state^n at r; world : cell_state^n at r;
let
  init<<r>> new_world = start fby world;
  ww = new_world;
world = game<<n, cell3<<n,30>> >>(ww, new_world);
tel


unsafe node main_0() = (w : cell_state^20)
let
  w = main<<20,[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]>>();
tel
*)

type cs = int (* cell state, is 0 or 1. *)
const null_cs : cs = 0

fun cs_of_int(i : int) = (s : cs)
let
  s = if i = 0 then 0 else 1
tel

(* See 1D cellular automaton
   http://en.wikipedia.org/wiki/Elementary_cellular_automaton *)
fun eca<<rule :int>>(x_1, x, x1 :cs) = (y :cs)
var nb :int;
let
  nb = (x_1 <<< 2) ||| (x <<< 1) ||| (x1);
  y = cs_of_int(rule &&& (1 <<< nb));
tel

(* This is a stream version, returning a value when 3 has been already fed:
   x0 x1 x2 x3 x4 x5
   .  .  y1 y2 y3 y4
   The 2 first values are false, then the result is one tick late.
   The signature could be seen has (n+2) -> (00n),
   but without lucyn, the signature is a -> a and
   the caller has to take care of the wrong values and delay.*)
node seq_cell<<rule :int>>(x1 : cs) = (y : cs)
var x_1, x : cs;
let
  x_1 = null_cs fby null_cs fby x1;
  x = null_cs fby x1;
  y = eca<<rule>>(x_1,x,x1);
tel



node circle<<n : int; first : cs^(n+2);>> (begin : bool; x : cs) = (y : cs^(n+2))
var yc1,yc :cs^(n+2); cpt, c :int;
let
  y = yc when begin;
  yc = first fby [yc1 with [cpt] = x];
  yc1 = if cpt = 2 then [yc with [n+1] = x]
        else if cpt = n+1 then [yc with [0] = x]
	else yc;
  cpt = Misc.mod_counter_r<<n+2>>(begin)-1;
  c = if cpt = -1 then n+1 else (if cpt = n+1 then 0 else cpt);
tel


(* Without inlining, it is non causal *)
node game<<n :int; rule :int; first : cs^(n+2);>> () = (y : cs^(n+2))
var begin : bool; x_l, y_l : cs;
let
  begin = Misc.timer<<n+2>>();
  x_l = Stream_arrays.a2s<<n+2>>(y, begin);

  y_l = seq_cell<<rule>>(x_l);

  y = inlined circle<<n, first>>(begin, y_l);
tel


node main_30() = (x :cs^(12))
let
  x = game<<10,30,0^12 >>();
tel



node circle_k<<k :int; n :int; first : cs^(n+2)>>(begin : bool; x : cs^(n+2)) = (y : cs^((n+2)*k))

let
  begin = cpt = 0;
  cpt = Misc.mod_counter_r<<n+2>>(begin);
  y1 = [y with 
  y = (first^n) fby y1;
  



node ppgame<<n,k :int; rule :int; first : cs^(n+2);>> () = (y : cs^((n+2)*k))
var last begin = 
let
  
  begin_chunck = Misc.timer<<n+2>>();
  chunk = Misc.mod_counter<<k>>() :: begin_chunk;
  begin_game = chunk = 0;

  x_l = Stream_arrays.a2s<<(n+2)*k>>(y, begin_game);
  
  xc = inlined Stream_arrays.s2a<<n+2>>(x_l, begin_chunck);
  yc = burstify<<seq_cell<<rule>>,n+2>>(xc); 
  y_l = inlined Stream_arrays.a2s<<n+2>>(yc, begin_chunk);
  
  y = inlined circle_k<<k, n, first>>(begin_game, y_l);
  
tel
