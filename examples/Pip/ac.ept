(** Counters *)

node counter(res:bool) = (cpt :int)
let
  reset
    cpt = 0 fby (cpt+1);
  every res
tel

(* count from 0 to n-1 *)
node mod_counter<<n :int>>() = (cpt :int)
let
  reset
    cpt = 0 fby (cpt + 1)
  every (false fby (cpt = n-1))
tel

(* count from 0 to n-1, reset to 0 when [res] *)
node mod_counter_r<<n :int>>(res :bool) = (cpt :int)
let
  reset
    cpt = 0 fby (cpt + 1)
  every (res or (false fby (cpt = n-1)))
tel


(** Timers *)

node timer<<n :int>>() = (t :bool)
let
  t = mod_counter<<n>>() = 0;
tel


(** Is false until the input is true, then stays true. *)
node watch(b : bool) = (o :bool)
let
  o = b or (false fby o)
tel

(** Waits [n] ticks before getting true *)
node wait<<n :int>>() = (go :bool)
let
    go = watch(false -> timer<<n>>())
tel

node current_i<<ini :int>>(x : int; ck : bool) = (y :int)
let
  y = merge ck (x) ((ini fby y) whenot ck)
tel

node current_ai<<n :int; ini :int^n>>(x :int^n; ck :bool) = (y :int^n)
let
  y = merge ck (x) ((ini fby y) whenot ck)
tel

(* Array to stream
    the boolean new_array should be declared as being true every [n] ticks (Misc.timer<<n>>())*)
node a2s <<n :int>> (x :int^n; new_array :bool) = (y :int)
var current_x :int^n; index :int;
let
  current_x = merge new_array (x) (((0^n) fby current_x) whenot new_array);
  index = mod_counter_r<<n>>(new_array);
  y = current_x[>index<];
tel
(* Stream to array
    a new array [y] is returned each n ticks (with a delay of n-1 ticks)*)
node s2a <<n:int>> (x :int; new_array :bool) = (y :int^n)
var current_y :int^n; index :int;
let
  current_y = (0^n) fby [current_y with [index] = x];
  index = mod_counter_r<<n>>(new_array);
  y = current_y when new_array;
tel

(* burstify a node, note that the first array is dummy *)
node burstify <<val node f(int)=(int); m : int;>> (x :int^m) = (y :int^m)
var base_clock : bool; stream_x, stream_y : int;
let
  base_clock = timer<<m>>();
  stream_x = a2s<<m>>(x, base_clock);
  stream_y = stream_x;
  y = s2a<<m>>(stream_y, base_clock);
tel
(*
type cell_state = int


(* Takes as input the observable world, and update the new_world at the given position *)
node alternate_cell<<n :int>>(world :cell_state^n; current_cell : cell_state; position :int; ) = (cell : cell_state)
let
  cell = if world[>position<] = 0 then 1 else 0;
tel

node cell3<<n :int; rule :int>>(world : cell_state^n; current_cell : cell_state; position :int;) = (cell : cell_state)
var nb,pos_1,pos1 :int;
let
  pos_1 = if position-1 < 0 then n-1 else position-1;
  pos1 = if position+1 >= n then 0 else position+1;
  nb = (world[>pos_1<] <<< 2) ||| (world[>position<] <<< 1) ||| (world[>pos1<]);
  cell = if bool_of_int(rule &&& (1 <<< nb)) then 1 else 0; (* we need to set true at 1 otherwise the above function is wrong *)
tel

node game<<n :int; val node cell (cell_state^n;cell_state;int) = (cell_state);>>
  (world : cell_state^n; new_world : cell_state^n at r) = (new_world_up : cell_state^n at r)
let
  new_world_up = mapi<<n>> cell <(world)> (new_world)
tel


unsafe node main<<n :int; start : cell_state^n>> () = (ww : cell_state^n;)
var new_world : cell_state^n at r; world : cell_state^n at r;
let
  init<<r>> new_world = start fby world;
  ww = new_world;
world = game<<n, cell3<<n,30>> >>(ww, new_world);
tel


unsafe node main_0() = (w : cell_state^20)
let
  w = main<<20,[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]>>();
tel
*)

type cs = int (* cell state, is 0 or 1. *)
const null_cs : cs = 0

fun cs_of_int(i : int) = (s : cs)
let
  s = if i = 0 then 0 else 1
tel

(* See 1D cellular automaton
   http://en.wikipedia.org/wiki/Elementary_cellular_automaton *)
fun eca<<rule :int>>(x_1, x, x1 :cs) = (y :cs)
var nb :int;
let
  nb = (x_1 <<< 2) ||| (x <<< 1) ||| (x1);
  y = cs_of_int(rule &&& (1 <<< nb));
tel

(* This is a stream version, returning a value when 3 has been already fed:
   x0 x1 x2 x3 x4 x5
   .  .  y1 y2 y3 y4
   The 2 first values are false, then the result is one tick late.
   The signature could be seen has (n+2) -> (00n),
   but without lucyn, the signature is a -> a and
   the caller has to take care of the wrong values and delay.*)
node seq_cell<<rule :int>>(x1 : cs) = (y : cs)
var x_1, x : cs;
let
  x_1 = null_cs fby null_cs fby x1;
  x = null_cs fby x1;
  y = eca<<rule>>(x_1,x,x1);
tel



node circle<<n : int; first : cs^(n+2);>> (begin : bool; x : cs) = (y : cs^(n+2))
var yc1,yc :cs^(n+2) at r; cpt :int;
let
  y = yc when begin;
  yc = first fby [yc1 with [cpt-1] = x];
  switch (cpt = 2)
  | true do yc1 = [yc with [n+1] = x];
  | false do
      switch (cpt = n+1)
      | true do yc1 = [yc with [0] = x];
      | false do yc1 = yc;
      end;
  end;
  (*yc1 = if cpt = 2 then [yc with [n+1] = x]
        else if cpt = n+1 then [yc with [0] = x]
	else yc;*)
  cpt = mod_counter_r<<n+2>>(begin);
tel


(* Without inlining, it is non causal *)
node game<<n :int; rule :int; first : cs^(n+2);>> () = (y : cs^(n+2))
var begin : bool; x_l, y_l : cs;
let
  begin = timer<<n+2>>();
  x_l = a2s<<n+2>>(y, begin);

  y_l = seq_cell<<rule>>(x_l);

  y = inlined circle<<n, first>>(begin, y_l);
tel


node main_seq<<n, rule :int;>>() = (y :cs^(n+2))
let
  y = game<<n, rule, 0^(n+2) >>();
tel


node main_30() = (x :cs^(12))
let
  x = game<<10, 30, 0^12 >>();
tel

(*
(* Dummy *)
node circle_k<<k :int; n :int; first : cs^(n+2);>>(begin : bool; x : cs) = (y : cs^((n+2)*k))
let
  y = 0^((n+2)*k) when begin;
tel  



node ppgame<<n,k :int; rule :int; first : cs^(n+2);>> () = (y : cs^((n+2)*k))
var begin_game, begin_chunk : bool; chunk : int; xc, yc : int^(n+2); x_l, y_l : int;
let
  
  begin_chunk = timer<<n+2>>();
  chunk = (mod_counter<<k>>() :: begin_chunk);
  begin_game = chunk = 0;

  x_l = a2s<<(n+2)*k>>(y, begin_game);
  
  xc = inlined s2a<<n+2>>(x_l, begin_chunk);
  yc = burstify<<seq_cell<<rule>>,n+2>>(xc); 
  y_l = inlined a2s<<n+2>>(yc, begin_chunk);
  
  y = inlined circle_k<<k, n, first>>(begin_game, y_l);
  
tel
*)

node current<<i : int>>(x : int; ck : bool) = (last y : int = i)
let
  y = merge ck (x) (last y whenot ck);
tel


(* while newone is true input game then when false output the result in ngame *)
node pppcore<<n,rule : int>>(left,right : cs; g : cs^n; newone : bool) = (ng : cs^n)
var 
  last local_right : cs :: . = 0; last local_game : cs^n at r :: . = 0^n;
  
  x_l : cs :: . ; y_l : cs :: . ;

  begin_lho : bool :: . ;

  llg : cs^n at r;
  
  lho_index : int :: . onot begin_lho; lho_last_local_game : cs^n at r:: . onot begin_lho;
  lho_y_l : cs :: . onot begin_lho; lho_x : cs :: . onot begin_lho;
  lho_game : cs^n at r :: . onot begin_lho; lho_local_right : cs :: . onot begin_lho;

let
  begin_lho = true fby (merge begin_lho (not newone) (lho_index = n));
  lho_index = mod_counter<<n+1>>();

  (* keep needed inputs during lho *)
  local_right = merge begin_lho (right) (last local_right whenot begin_lho);

  (* modify in place local_game, initialy a copy of g *)
  local_game = merge begin_lho (reinit(llg,g)) (lho_game);

  (* compute the game *)
  x_l = merge begin_lho (left) (lho_x);
  y_l = seq_cell<<rule>>(x_l);
  
  (* when in lho (not begin_lho) *)
  (llg, lho_last_local_game) = split begin_lho (last local_game);
  lho_y_l = y_l whenot begin_lho;
  lho_local_right = local_right whenot begin_lho;
  automaton
    state Begin
    do
      lho_x = (lho_last_local_game)[0];
      lho_game = lho_last_local_game; (* do not store any result for now *)
    until true then Middle
    state Middle
    do
      lho_x = (lho_last_local_game)[>lho_index<];
      lho_game = [lho_last_local_game with [lho_index-1] = lho_y_l];
    until lho_index = n - 1 then Last
    state Last
    do
      lho_x = lho_local_right;
      lho_game = [lho_last_local_game with [n-1] = lho_y_l];
    until true then Begin
  end;

  ng = last local_game when begin_lho whenot newone;
tel


node pppgame<<n, k, rule :int;first : cs^n;>> () = (y : cs^n^k)
var
  last g : cs^n^k at r2 = first^k; lgw,lgwn : cs^n^k at r2;
  last ng : cs^n^k at r = first^k; lngw, lngwn : cs^n^k at r;
  last stut_index : int = -1;
  last stut_left_index : int = -1;
  last stut_right_index : int = -1;
  index, left_index, right_index : int;
  stut_left, stut_right : cs;
  newone, swap : bool;
  chunk, prev_chunk : cs^n;
let
  
  index = mod_counter<<k>>();

  left_index = if index -1 < 0 then k-1 else index -1;
  right_index = if index +1 > k-1 then 0 else index +1;
  
  (* stutter on half because of computation delay *)
  newone = true fby (not newone);
  stut_left_index = merge newone (left_index) (last stut_left_index whenot newone);
  stut_right_index = merge newone (right_index) (last stut_right_index whenot newone);
  stut_index = merge newone (index) (last stut_index whenot newone);

  stut_right = g[>stut_right_index<][>0<];
  stut_left = g[>stut_left_index<][>n-1<];
  prev_chunk = g[>stut_index<];
  chunk = pppcore<<n,rule>>(stut_left, stut_right, prev_chunk, newone);
  
  (lngw,lngwn) = split newone (last ng);
  ng = merge newone (lngw) ([lngwn with [stut_index whenot newone] = chunk]);
  
  (lgw, lgwn) = split swap (last g);
  g = merge swap (reinit(lgw,last ng when swap)) (lgwn);

  swap = merge newone (index = 0) (false);
  
  y = g when swap;
tel

node a_pppgame<<n, k, rule :int;first : cs^n;>> () = (y : cs^n^k)
var last g : (future cs^n)^k at r2 = (async first)^k; lgw,lgwn : (future cs^n)^k at r2;
  last ng : (future cs^n)^k at r = (async first)^k; lngw,lngwn : (future cs^n)^k at r;
  last stut_index : int = -1;
  last stut_left_index : int = -1;
  last stut_right_index : int = -1;
  index, left_index, right_index : int;
  stut_left, stut_right : cs;
  newone, swap : bool;
  chunk : future cs^n;
  prev_chunk : cs^n;
let
  
  index = mod_counter<<k>>();

  left_index = if index -1 < 0 then k-1 else index -1;
  right_index = if index +1 > k-1 then 0 else index +1;
  
  (* stutter on half because of computation delay *)
  newone = true fby (not newone);
  stut_left_index = merge newone (left_index) (last stut_left_index whenot newone);
  stut_right_index = merge newone (right_index) (last stut_right_index whenot newone);
  stut_index = merge newone (index) (last stut_index whenot newone);

  stut_right = (!(g[>stut_right_index<]))[>0<];
  stut_left = (!(g[>stut_left_index<]))[>n-1<];
  prev_chunk = !(g[>stut_index<]);
  reset chunk = async<<3,k+1>> pppcore<<n,rule>>(stut_left, stut_right, prev_chunk, newone) every newone;
  
  (lngw,lngwn) = split newone (last ng);
  ng = merge newone (lngw) ([lngwn with [stut_index whenot newone] = chunk]);
      
  (lgw, lgwn) = split swap (last g);
  g = merge swap (reinit(lgw,last ng when swap)) (lgwn);

  swap = merge newone (index = 0) (false);
  
  y = map<<k>> (!) (g when swap);
tel


node ca_pppgame<<n, k, rule :int;first : cs^n;>> () = (y : cs^n^k)
var last g : (future cs^n)^k at r2 = (async first)^k; lgw,lgwn : (future cs^n)^k at r2;
  last ng : (future cs^n)^k at r = (async first)^k; lngw,lngwn : (future cs^n)^k at r;
  last stut_index : int = -1;
  last stut_left_index : int = -1;
  last stut_right_index : int = -1;
  mod_index, index, left_index, right_index : int;
  stut_left, stut_right : cs;
  newone, swap : bool;
  chunk : future cs^n;
  prev_chunk : cs^n;
  abs_index, offset : int;
let
  
  offset = merge swap (mod_counter<<k>>()) ((0 fby offset) whenot swap);

  abs_index = mod_counter<<k>>();
  index = abs_index + (offset when newone);
  mod_index = if index > k-1 then index - k else index;
  left_index = if mod_index -1 < 0 then k-1 else mod_index -1;
  right_index = if mod_index +1 > k-1 then 0 else mod_index +1;
  
  (* stutter on half because of computation delay *)
  newone = true fby (not newone);
  stut_left_index = merge newone (left_index) (last stut_left_index whenot newone);
  stut_right_index = merge newone (right_index) (last stut_right_index whenot newone);
  stut_index = merge newone (mod_index) (last stut_index whenot newone);

  stut_right = (!(g[>stut_right_index<]))[>0<];
  stut_left = (!(g[>stut_left_index<]))[>n-1<];
  prev_chunk = !(g[>stut_index<]);
  reset chunk = async<<3,k+1>> pppcore<<n,rule>>(stut_left, stut_right, prev_chunk, newone) every newone;
  
  (lngw,lngwn) = split newone (last ng);
  ng = merge newone (lngw) ([lngwn with [stut_index whenot newone] = chunk]);
      
  (lgw, lgwn) = split swap (last g);
  g = merge swap (reinit(lgw,last ng when swap)) (lgwn);

  swap = merge newone (abs_index = 0) (false);
  
  y = map<<k>> (!) (g when swap);
tel
