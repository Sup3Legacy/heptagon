
(*
type cell_state = int


(* Takes as input the observable world, and update the new_world at the given position *)
node alternate_cell<<n :int>>(world :cell_state^n; current_cell : cell_state; position :int; ) = (cell : cell_state)
let
  cell = if world[>position<] = 0 then 1 else 0;
tel

node cell3<<n :int; rule :int>>(world : cell_state^n; current_cell : cell_state; position :int;) = (cell : cell_state)
var nb,pos_1,pos1 :int;
let
  pos_1 = if position-1 < 0 then n-1 else position-1;
  pos1 = if position+1 >= n then 0 else position+1;
  nb = (world[>pos_1<] <<< 2) ||| (world[>position<] <<< 1) ||| (world[>pos1<]);
  cell = if bool_of_int(rule &&& (1 <<< nb)) then 1 else 0; (* we need to set true at 1 otherwise the above function is wrong *)
tel

node game<<n :int; val node cell (cell_state^n;cell_state;int) = (cell_state);>>
  (world : cell_state^n; new_world : cell_state^n at r) = (new_world_up : cell_state^n at r)
let
  new_world_up = mapi<<n>> cell <(world)> (new_world)
tel


unsafe node main<<n :int; start : cell_state^n>> () = (ww : cell_state^n;)
var new_world : cell_state^n at r; world : cell_state^n at r;
let
  init<<r>> new_world = start fby world;
  ww = new_world;
world = game<<n, cell3<<n,30>> >>(ww, new_world);
tel


unsafe node main_0() = (w : cell_state^20)
let
  w = main<<20,[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0]>>();
tel
*)

type cs = int (* cell state, is 0 or 1. *)
const null_cs : cs = 0

fun cs_of_int(i : int) = (s : cs)
let
  s = if i = 0 then 0 else 1
tel

(* See 1D cellular automaton
   http://en.wikipedia.org/wiki/Elementary_cellular_automaton *)
fun eca<<rule :int>>(x_1, x, x1 :cs) = (y :cs)
var nb :int;
let
  nb = (x_1 <<< 2) ||| (x <<< 1) ||| (x1);
  y = cs_of_int(rule &&& (1 <<< nb));
tel

(* This is a stream version, returning a value when 3 has been already fed:
   x0 x1 x2 x3 x4 x5
   .  .  y1 y2 y3 y4
   The 2 first values are false, then the result is one tick late.
   The signature could be seen has (n+2) -> (00n),
   but without lucyn, the signature is a -> a and
   the caller has to take care of the wrong values and delay.*)
node seq_cell<<rule :int>>(x1 : cs) = (y : cs)
var x_1, x : cs;
let
  x_1 = null_cs fby null_cs fby x1;
  x = null_cs fby x1;
  y = eca<<rule>>(x_1,x,x1);
tel



node circle<<n : int; first : cs^(n+2);>> (begin : bool; x : cs) = (y : cs^(n+2))
var yc1,yc :cs^(n+2); cpt, c :int;
let
  y = yc when begin;
  yc = first fby [yc1 with [cpt] = x];
  yc1 = if cpt = 2 then [yc with [n+1] = x]
        else if cpt = n+1 then [yc with [0] = x]
	else yc;
  cpt = Misc.mod_counter_r<<n+2>>(begin)-1;
  c = if cpt = -1 then n+1 else (if cpt = n+1 then 0 else cpt);
tel


(* Without inlining, it is non causal *)
node game<<n :int; rule :int; first : cs^(n+2);>> () = (y : cs^(n+2))
var begin : bool; x_l, y_l : cs;
let
  begin = Misc.timer<<n+2>>();
  x_l = Stream_arrays.a2s<<n+2>>(y, begin);

  y_l = seq_cell<<rule>>(x_l);

  y = inlined circle<<n, first>>(begin, y_l);
tel


node main_30() = (x :cs^(12))
let
  x = game<<10,30,0^12 >>();
tel



node circle_k<<k :int; n :int; first : cs^(n+2);>>(begin : bool; x : cs) = (y : cs^((n+2)*k))
let
  y = 0^((n+2)*k) when begin;
tel  



node ppgame<<n,k :int; rule :int; first : cs^(n+2);>> () = (y : cs^((n+2)*k))
var begin_game, begin_chunk : bool; chunk : int; xc, yc : int^(n+2); x_l, y_l : int;
let
  
  begin_chunk = Misc.timer<<n+2>>();
  chunk = (Misc.mod_counter<<k>>() :: begin_chunk);
  begin_game = chunk = 0;

  x_l = Stream_arrays.a2s<<(n+2)*k>>(y, begin_game);
  
  xc = inlined Stream_arrays.s2a<<n+2>>(x_l, begin_chunk);
  yc = Stream_arrays.burstify<<seq_cell<<rule>>,n+2>>(xc); 
  y_l = inlined Stream_arrays.a2s<<n+2>>(yc, begin_chunk);
  
  y = inlined circle_k<<k, n, first>>(begin_game, y_l);
  
tel

node main_2()=(y:cs^8)
let
  y = ppgame<<2,2,30,0^4>>();
tel

(* while newone is true input game then when false output the result in ngame *)
node ppcore<<n,rule : int>>(left,right : cs; g : cs^n; newone : bool) = (ng : cs^n)
var last local_game : cs^n = 0^n; begin_lho : bool; x_l, y_l : cs; lho_x : cs; lho_game, last_lho_game : cs^n; local_newone : bool; last local_right : cs = 0;

let
  local_newone = merge begin_lho (newone) (false fby local_newone);
  begin_lho = true fby (merge local_newone (n+1 = Misc.mod_counter<<n+2>>()) (true));
  local_right = merge begin_lho (right) (last local_right whenot begin_lho);
  x_l = merge begin_lho (left) (lho_x);
  y_l = seq_cell<<rule>>(x_l);
  automaton
    state Begin
    do
      lho_x = (last_lho_game)[0];
      lho_game = last_lho_game;
    until true then Middle
    state Middle
    var cpt : int;
    do
      cpt = 1 fby (cpt + 1);
      lho_x = (last_lho_game)[>cpt<];
      lho_game = [last_lho_game with [cpt-1] = y_l whenot begin_lho];
    until cpt = n - 1 then Last
    state Last
    do
      lho_x = local_right whenot begin_lho;
      lho_game = [last_lho_game with [n] = y_l whenot begin_lho];
    until true then Begin
  end;
  ng = local_game when begin_lho;
  last_lho_game = last local_game whenot begin_lho;
  local_game = merge begin_lho (g) (last_lho_game);
tel


(*
node ppgame<<n, k, rule :int;first : cs^(n+2)>> () = (y : cs^n^k)
var g : (future cs^n)^k; 
let
  g = (first^k) fby ng;





*)
