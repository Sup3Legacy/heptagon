(* Extended game of life with majority rules : a cell takes the color of the majority  *
 * A small addition : if a cell has a color for too long, it is harder to change       *)

const r : int = 4 (* The width for neighbors *)
const b : int = 2 * r + 1 (* The width to consider when checking neighbors *)

const size : int = 16 (* The size of a tile *)
const osize : int = size + r * 2 (* The size of a tile and its neighbors *)
const nbr : int = 30 (* The number of tiles in a row *)


fun add(a : local int^osize^osize; i, j, k, l, acc : int)
    returns(o : int)
  let
    o = a[> i + k <][> j + l <] + acc;
  tel

(* A cell *)
node life_cell(a : local int^osize^osize; i, j : int)
     returns(o : int)
  var t : int; last k : int = 0;
  let
    (* Computes the number of each states (binary) *)
    t = foldi<<b, b>> add<(a, i, j)> (0);
    automaton
      state Init
        do
          o = a[>i + r<][>j + r<];
        until
          o = 1 then Alive
        | true then Dead

      state Alive
        do
          k = 0 fby (k + 1);
          o = 1;
        unless
          t < 41 & last k < 20 then Dead
        | t < 36 then Dead

      state Dead
        do
          k = 0 fby (k + 1);
          o = 0;
        unless
          t > 40 & last k < 20 then Alive
        | t > 45 then Dead
    end;
  tel

(* The position in the original board from the position in the local matrice *)
fun newi(i, i2 : int) returns(ni, ni2 : int)
  let
    switch (i2 < r)
      | true do
          ni = (i - 1) % nbr;
          ni2 = size - r + i2;
      | false do
          switch (i2 >= size + r)
            | true do
                ni = (i + 1) % nbr;
                ni2 = i2 - size - r;
            | false do
                ni = i;
                ni2 = i2 - r;
          end;
    end;
  tel

(* Fills a local matrice with the current tile and its neighbors *)
fun fill_loc(a : global int^size^size^nbr^nbr; i, j, i2, j2 : int) returns(o : int)
  var ni, nj, ni2, nj2 : int;
  let
    (ni, ni2) = newi(i, i2);
    (nj, nj2) = newi(j, j2);
    o = a[>ni<][>nj<][>ni2<][>nj2<];
  tel

(* Distributes the computations in a work-group *)
node game_of_life(a : global int^size^size^nbr^nbr; i, j : int) returns(o : local int^size^size)
  var a_loc : local int^osize^osize;
  let
    a_loc = pmapi<<osize, osize>> fill_loc<(a, i, j)> ();
    o = pmapi<<size, size>> life_cell<(a_loc)> ();
  tel

(* A step of the game of life *)
kernel game_of_life_par(a : global int^size^size^nbr^nbr) returns(o : global int^size^size^nbr^nbr)
  let
    o = mapi<<nbr, nbr>> game_of_life<(a)> ();
  tel

(* A simple function to play the game of life *)
node aux(e : bool) returns(o : int^size^size^nbr^nbr on e)
  var c, d : global int^size^size^nbr^nbr;
  let
    c = (0^size^size^nbr^nbr) fby d;
    d = game_of_life_par(c);
    o = d when e;
  tel
