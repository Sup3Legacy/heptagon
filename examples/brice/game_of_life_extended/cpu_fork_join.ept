
const extendedLife_majority : int = 1

const size : int = 32
const osize : int = 42
const nbr : int = 15
const sn : int = size * nbr

const r : int = 4
const b : int = 2 * r + 1

fun mult_add(a : int^sn^sn; i, j, k, l, acc : int)
    returns(o : int)
  let
    o = a[> (i + k - r) % sn <][> (j + l - r) % sn <] + acc;
  tel

node life_cell(a : int^sn^sn; c, i, j : int)
     returns(o : int)
  var t : int; last k : int = 0;
  let
    t = foldi<<b, b>> mult_add<(a, i, j)> (0);
    automaton
      state Init
        do
          o = c;
        until
          o = 1 then Alive
        | true then Dead

      state Alive
        do
          k = 0 fby (k + 1);
          o = 1;
        unless
          t < 41 & last k < 20 then Dead
        | t < 36 then Dead

      state Dead
        do
          k = 0 fby (k + 1);
          o = 0;
        unless
          t > 40 & last k < 20 then Alive
        | t > 45 then Dead
    end;
  tel

node game_of_life_par() returns()
  var c, d : int^sn^sn;
  let
    c = (0^sn^sn) fby d;
    d = map<<sn, sn>> (!) (mapi<<sn, sn>> async life_cell<(c)> (c));
  tel

