open Utils

const iwidth : int = 1920
const owidth : int = 720

const iheight : int = 1080
const oheight : int = 480

const iwidth2 : int = iwidth + 2

const rgb_empty : Utils.rgb = {Utils.r = 0; Utils.g = 0; Utils.b = 0}



(* takes a flow of rgb and gives the corresponding array of rgbs *)
node r2ap(r : Utils.rgb)
     returns(last a : Utils.rgb^iwidth2^3 = rgb_empty^iwidth2^3)
  var k, w : int;
  let
    w = 1 -> if (pre w = iwidth) then 1 else pre w + 1;
    k = 0 -> if (w = 1) then pre k + 1 else pre k;
    a = [ last a with [k][w] = r ];
  tel




(* does the convolution of a 3*3 matrix of ints *)
fun iconv(a, z, e, r, t, y, u, i, o : int) returns(c : int)
  var fa, fz, fe, fr, ft, fy, fu, fi, fo : float;
  let
    c = (fa + fz + fe + fr + 8*ft + fy + fu + fi + fo) / 16;
  tel


(* does the convolution of a 3*3 matrix of rgbs *)
fun rgbconv(a, z, e, r, t, y, u, i, o : Utils.rgb) returns(c : Utils.rgb)
  var cr, cb, cg : int;
  let
    cr = iconv(a.r, z.r, e.r, r.r, t.r, y.r, u.r, i.r, o.r);
    cg = iconv(a.g, z.g, e.g, r.g, t.g, y.g, u.g, i.g, o.g);
    cb = iconv(a.b, z.b, e.b, r.b, t.b, y.b, u.b, i.b, o.b);
    c = {Utils.r = cr; Utils.g = cg; Utils.b = cb};
  tel


(* does the convolution of a given index in the array *)
fun mconv(a : Utils.rgb^iwidth2^3; k : int; r : Utils.rgb; w : int) returns(o : Utils.rgb)
  var ki, ks : int;
  let
    ki = (k - 1) % 3;
    ks = (k + 1) % 3;
    o = if (w = 0 or w = iwidth + 1) then
          rgb_empty
        else
          rgbconv((a [>ki<])[>w - 1<], (a [>ki<])[>w<], (a [>ki<])[>w + 1<],
                  (a [>k<] )[>w - 1<], (a [>k<] )[>w<], (a [>k<] )[>w + 1<],
                  (a [>ks<])[>w - 1<], (a [>ks<])[>w<], (a [>ks<])[>w + 1<]);
  tel



(* does the convolution *)
node conv(a : Utils.rgb^iwidth2^3) returns(o : Utils.rgb^iwidth2)
  var k : int;
  let
    k = 0 -> if (pre k = 2) then 0 else pre k + 1;
    o = mapi<<iwidth2>> mconv (<a,k>) (a[>k<]);
    (*o = mconv(a, k, rgb_empty, 0);*)
  tel


(* takes the array and returns a flow of rgbs *)
node a2r(a : Utils.rgb^iwidth2) returns(r : Utils.rgb)
  var w : int;
  let
    w = 1 -> if (pre w = iwidth) then 1 else pre w + 1;
    r = a[>w<];
  tel



(* the main function *)
node main(r : Utils.rgb) returns(o : Utils.rgb; last e : bool = false)
  var a : Utils.rgb^iwidth2^3; last t : Utils.rgb^iwidth2 = rgb_empty^iwidth2; last k : int = 0;
  let
    a = r2ap(r);
    e = last e or (last k >= iwidth * 2 - 1);
    t = if (last k = iwidth * 2 - 1) then conv(a) else last t;
    o = a2r(t);
    k = if (last k = iwidth * 2 - 1) then iwidth else last k + 1;
  tel
