\documentclass[a4paper]{article}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage{lmodern}
\usepackage{amsmath}
%\usepackage{tikz}
%\usepackage{cite}
\usepackage{hyperref}
%\usepackage{fancyvrb}
%\usepackage{bm}
%\usepackage{pxfonts}
\usepackage{verbatim}
\usepackage{a4wide}
\usepackage{graphicx}

\hypersetup{
  backref=true, %permet d'ajouter des liens dans...
  pagebackref=true,%...les bibliographies
  hyperindex=true, %ajoute des liens dans les index
  colorlinks=true, %colorise les liens
  breaklinks=true, %permet le retour a la ligne dans les liens trop longs
  urlcolor=blue,  %couleur des hyperliens (blue pour la version web)
  linkcolor=blue, %couleur des liens internes (blue pour la version web)
  citecolor=blue, %couleur des citation (green pour la version web)
  bookmarks=true,  %cree des signets pour Acrobat
  bookmarksopen=true, %affiche completement les signets Acrobat
  %%%%%%%%%%%%%%%%% HYPER TITLE %%%%%%%%%%%%%%%%%%%%%%%%%%
  pdfsubject={Rapport} %document sous Acrobat.
}

% Alter some LaTeX defaults for better treatment of figures:
% See p.105 of "TeX Unbound" for suggested values.
% See pp. 199-200 of Lamport's "LaTeX" book for details.
% General parameters, for ALL pages:

%\renewcommand{\topfraction}{0.9}  % max fraction of floats at top
%\renewcommand{\bottomfraction}{0.8} % max fraction of floats at bottom


% Parameters for TEXT pages (not float pages):

%\setcounter{topnumber}{2}
%\setcounter{bottomnumber}{2}
%\setcounter{totalnumber}{4}     % 2 may work better
%\setcounter{dbltopnumber}{2}    % for 2-column pages

%\renewcommand{\dbltopfraction}{0.9} % fit big float above 2-col. text
%\renewcommand{\textfraction}{0.07}  % allow minimal text w. figs
% Parameters for FLOAT pages (not text pages):
%\renewcommand{\floatpagefraction}{0.7}  % require fuller float pages
% N.B.: floatpagefraction MUST be less than topfraction !!
%\renewcommand{\dblfloatpagefraction}{0.7} % require fuller float pages

% remember to use [htp] or [htpb] for placement


\newcommand{\FIXME}{\textcolor{red}{FIXME}}
%\newcommand{\TODO}[1]{(\textcolor{red}{TODO} #1)}
\newcommand{\TODO}[1]{}
\newcommand{\LANG}{{\sc Heptagon}}
\newcommand{\lucy}{{\sc Lucid Synchrone}}
\newcommand{\lustre}{{\sc Lustre}}
\newcommand{\scade}{{\sc Scade}}
\newcommand{\scadesix}{{\sc Scade~6}}
\newcommand{\minils}{{\sc MiniLS}}
\newcommand{\heptagon}{{\sc Heptagon}}
\newcommand{\obc}{{\sc Obc}}
\newcommand{\minivhdl}{{\sc MiniVHDL}}
\newcommand{\vhdl}{{\sc Vhdl}}


\newcommand{\bold}[1]{\textbf{#1}}
\newcommand{\p}[0]{\; \vert \;}
\newcommand{\rst}[1]{Rst(#1)}
\newcommand{\rstnd}[1]{RstNode(#1)}
% \newcommand{\rst}[1]{\llbracket #1 \rrbracket^{rst}}
\newcommand{\tvh}[2]{\llbracket #2 \rrbracket^{vhdl\ #1}}
\newcommand{\guardb}[1]{\llbracket #1 \rrbracket^{guard}}
\newcommand{\guard}[2]{\mbox{if } \guardb{#1} \mbox{ then } #2 \mbox{ else }
  \emptyset}
\newcommand{\mybox}[1]{\mbox{\tt{#1}}}
\newcommand{\bl}[0]{\hspace{0.45cm}}
\newcommand{\ind}[0]{\hspace{0.5cm}}
\newcommand{\Cons}[0]{\; \mathbf{::} \;}
\newcommand{\Coloneqq}[0]{::=}
\newcommand{\coloneqq}[0]{::=}
%% Syntaxe MiniLS

\newcommand{\Node}[4]{\mybox{node} \; f(#1) = #2 \; \mybox{with var} \
  #3 \; \mybox{in} \; #4}
\newcommand{\Op}[2]{\mybox{\bf{op}}(#1,\dots,#2)}
\newcommand{\Fby}[2]{#1 \, \mybox{fby}^{ck} \, #2}
\newcommand{\Pre}[1]{\mybox{pre}^{ck} \, #1}
\newcommand{\Every}[4]{#1^{ck}(#2,\dots,#3) \, \mybox{every} \, #4}
\newcommand{\App}[2]{#1^{ck}(#2)}
\newcommand{\If}[3]{\mybox{if} \; #1 \; \mybox{then} \; #2 \; \mybox{else} \; #3}
\newcommand{\When}[3]{#1 \; \mybox{when} \; #2(#3)}
\newcommand{\Merge}[5]{\mybox{merge} \; #1 \; (#2 \Rightarrow #3) \; \dots \; \
  (#4 \Rightarrow #5)}
\newcommand{\Merges}[5]{\mybox{merge} \; #1 \; (#2 \Rightarrow #3) \; \
  (#4 \Rightarrow #5)}
\newcommand{\Base}[0]{\mybox{base}}
\newcommand{\On}[3]{#1 \; \mybox{on} \; #2 (#3)}
\newcommand{\Map}[3]{\mathtt{map} \; #1\; n\; (#2,\dots,#3)}
\newcommand{\Fold}[3]{\mathtt{fold} \; #1\; n\; (#2,\dots,#3)}
\newcommand{\Mapfold}[3]{\mathtt{mapfold} \; #1\; n\; (#2,\dots,#3)}

%% Syntaxe VHDL

\newcommand{\Component}[6]{\mybox{component} \; #1 \; \mybox{port} \; #2 \; \
  \mybox{with} \; \mybox{sig} \; #3 \; \mybox{and} \; \mybox{var} \; #4 \; \\
  \mybox{and} \; \mybox{subcomponents} \; #5 \; \mybox{in} \; #6}

\newcommand{\Assign}[2]{#1 \Leftarrow #2}
\newcommand{\Affect}[2]{#1 \coloneqq #2}
\newcommand{\Case}[5]{\mybox{case} \; #1 \; \mybox{of} \; (#2 \Rightarrow #3) \
  \dots (#4 \Rightarrow #5)}
                                                                              
\title{Traduction SCADE/Lustre vers VHDL~\thanks{Rapport d'\'etude dans
    le cadre du projet GENCOD.}}  \author{Adrien Guatto et Marc Pouzet
  \\ LRI~\thanks{Marc Pouzet est maintenant professeur \`a l'Universit\'e
    Pierre et Marie Curie et rattach\'e \`a l'\'Ecole normale
    sup\'erieure. Adrien Guatto, \'etudiant de l'Universit\'e Pierre et
    Marie Curie, a effectu\'e son stage dans le cadre du projet.}}
\date{31 aout 2010}

\begin{document}

\maketitle

\section{Introduction}
Ce document pr\'esente le probl\`eme de la compilation d'un langage
synchrone tel que SCADE vers un langage pour le mat\'eriel et les
circuits tel que VHDL. Nous d\'ecrivons le probl\`eme pos\'e, les
principales solutions envisag\'ees et la solution propos\'ee par le LRI.

Ce travail s'est appuy\'e sur la r\'ealisation d'un prototype d'\'etude,
appel\'e \LANG{}. Il s'agit d'un compilateur produisant \`a la fois du
code s\'equentiel (ici, principalement C et Java) et du code VHDL \`a
partir d'un programme synchrone. Le langage d'entr\'ee est un
sous-ensemble de \scadesix{} et en reprend les principales
constructions: \'equations data-flow, automates hi\'erarchiques et
tableaux. Son compilateur est organis\'e de mani\`ere similaire au
compilateur KCG de \scade{} d\'evelopp\'e par
Esterel-Technologies~\footnote{Pour \^etre complet, \LANG{} est un
  sous-ensemble du langage \lucy~\cite{lucy:manual06} dont plusieurs
  traits sont int\'egr\'es \`a \scadesix. Nous aurions donc pu
  r\'ealiser un prototype d'\'etude \`a partir de \lucy. Le
  langage \'etant plus riche (ordre sup\'erieur, inf\'erence de type,
  polymorphisme, etc.), cela n\'ecessitait de r\'esoudre des probl\`emes peu
  pertinents pour le projet GENCOD. D'o\`u le choix de consid\'erer un
  langage simplifi\'e.}.  Le prototype
\LANG{} a \'et\'e mis a la disposition des partenaires du projet GENCOD.

\subsection{Compilation de SCADE/Lustre vers VHDL}

\begin{figure}[t]
\begin{center}
\includegraphics[height=4cm]{Fig/compil-scade}
\end{center}
\caption{Organisation g\'en\'erale du compilateur de SCADE~\label{organisation-scade}}
\end{figure}

Rapellons l'organisation g\'en\'erale du compilateur KCG
(Figure~\ref{organisation-scade}).  La compilation d'un programme se
d\'eroule en quatre grandes \'etapes: 1/ une phase d'analyse statique
(typage~\cite{lucy:emsoft03}, calcul d'horloges~\cite{lucy:emsoft04},
analyse de causalit\'e et analyse d'initialisation~\cite{lucy:sttt04});
2/ une phase comportant une succession de r\'e\'ecritures produisant \`a la
fin un code data-flow avec horloges; cette \'etape \'elimine les
principales structures de contr\^ole (automates, conditions
d'activations) en produisant des \'equations ``gard\'ees''; 3/ une phase
de compilation du code data-flow vers du code imp\'eratif s\'equentiel
(object code); chaque noeud \scade{} est repr\'esent\'e par une fonction
de transition; 4/ une phase d'optimisation appliqu\'ee au code
s\'equentiel (\'elimination des copies, propagation de constantes,
etc.). Au pr\'ealable \`a cette phase, les modules sont expans\'es et le
code polymorphe est sp\'ecialis\'e. Ces deux \'etapes pr\'eliminaires ne sont
pas d\'ecrites ici.

Au regard de cette organisation, il y a deux points d'entr\'ees naturels
pour produire du code VHDL:
\begin{enumerate}
\item \`a partir du code interm\'ediaire dataflow avec horloges, apr\`es
  \'elimination des structures de contr\^ole (e.g., automates, conditions
  d'activation);
\item
\`a partir du code final g\'en\'er\'e par le compilateur (dans le cas de KCG, le
code C).
\end{enumerate}

Remarquons que le code interm\'ediaire data-flow est d\'ej\`a un point d'entr\'ee pour les
outils de v\'erification formelle utilis\'es dans le compilateur KCG (tels que
le plug-in de Prover Technology): la v\'erification d'une propri\'et\'e (programm\'ee
en \scade) est obtenue par traduction pr\'ealable vers le format data-flow,
format qui sert de passerelle vers l'outil Prover.

\subsection{G\'en\'eration de VHDL \`a partir d'\'equations data-flow gard\'ees}
Les deux solutions d\'ecrites ci-dessus ont \'et\'e retenues dans le projet
GENCOD. La soci\'et\'e GeenSoft a r\'ealis\'e un compilateur \`a partir du code
C g\'en\'er\'e par KCG. Nous d\'ecrivons ici l'autre solution o\`u le code VHDL
est produit directement \`a partir des \'equations data-flow. Pour cela, nous
d\'ecrivons formellement chacune des \'etapes de traduction, dans une perspective
d'int\'egration dans une cha\^{\i}ne de compilation certifi\'ee.

L'utilisation de Lustre pour la g\'en\'eration de mat\'eriel a \'et\'e envisag\'ee
tr\`es t\^ot (th\`ese de Fr\'ederic Rocheteau~\cite{lustre:rocheteau91}). Signalons
\'egalement que \lustre{} est utilis\'e dans plusieurs enseignements de
mat\'eriel~\cite{lustre:amblard05}.

\subsubsection{Un mot sur la traduction de C vers VHDL}
L'int\'er\^et principal de produire du code VHDL \`a partir du code C g\'en\'er\'e par KCG est
de ne pas toucher au compilateur existant, d\'eja qualifi\'e. \`A condition
de qualifier le g\'en\'erateur de code C vers VHDL et de fournir les
informations de retour au source (tra\c{c}abilit\'e), on peut envisager de disposer 
d'une cha\^{\i}ne qualifi\'ee. Discutons ici des points d\'elicats de cette solution.

La compilation de SCADE est modulaire: un noeud \texttt{counter}
est traduit vers deux fonctions
C dont l'interface est sch\'ematiquement:

\begin{verbatim}
/* counter.c */
int counter_step(int counter_res, int counter_tick, counter_mem* self) { ... }

void counter_init(counter_mem* self)
  { self->counter_t1 = 0;
    self->counter_t2 = 0; }
\end{verbatim}
o\`u:
\begin{verbatim}
typedef struct { 
  int counter_t1; 
  int counter_t2; }
counter_mem;
\end{verbatim}
\texttt{counter\_step} est la fonction de transition qui prend
en entr\'ee un argument suppl\'ementaire repr\'esentant son \'etat interne. L'ex\'ecution
d'un pas produit une sortie et met \`a jour l'\'etat interne (par effet de bord).
La fonction \texttt{counter\_init} permet d'initialiser l'\'etat interne.

Le corps de ces deux fonctions est form\'e d'affectations de variables
locales o\`u de l'\'etat (ici \texttt{self}) ainsi que de structures de
contr\^ole (conditionnelles, construction ``switch'' et boucles ``for''
o\`u d'appel \`a d'autres fonctions de transition). La g\'en\'eration de code
VHDL suit le sch\'ema suivant:

\begin{enumerate}
\item Une affectation de variable locale est traduite par une \'equation
  VHDL sur une variable locale. E.g., \texttt{$x$ = $e$} est traduit
  sch\'ematiquement en une equation VHDL \texttt{$x$ := $e$}.  Il faut
  cependant \^etre tr\`es attentif \`a ce que \verb-x- ne g\'en\`ere pas de
  registre.  Ce point est assez d\'elicat puisque, en particulier lors
  de la traduction de \texttt{if $cond$ \{ $x$ = $exp$; \}}. Il
  correspond \`a la d\'efinition d'un flot dont l'horloge est
  $cond$. Parce que sa d\'efinition est partielle (la valeur de $x$ est
  ind\'efinie lorsque $cond$ est faux, sa traduction en VHDL va conduire
  le synth\'etiseur \`a allouer un registre pour $x$, ce qui est \`a la fois
  inutile et inefficace.  Dans le cas o\`u le programme en entr\'ee n'a
  pas d'effets de bord, la s\'emantique de SCADE garantit que ce
  programme est \'equivalent \`a l'affectation simple $x$ = $exp$.
\item Une affectation de variable d'\'etat \texttt{self->$t$ =
    $exp$} doit \^etre traduite vers une equation de la forme
  \texttt{$t$ <= $exp$}. Cette affectation doit cependant \^etre ex\'ecut\'ee
  conditionnellement. Il faut donc retrouver, dans le code C,
  la condition bool\'eenne d'activation de la mise \`a jour de
  l'\'etat \texttt{self->$t$}.
\item La compilation des it\'erateurs (et plus largement des op\'erations de
manipulation des tableaux) est \'egalement d\'elicate. Une \'equation de la forme:
\begin{verbatim}
t1 = map not <<10>>(t0)
\end{verbatim}
o\`u \verb-t1- et \verb-t0- sont deux tableaux de taille 10 de valeurs
bool\'eennes. Le code imp\'eratif produit le compilateur de \scade{} a
la forme suivante~\footnote{Nous donnons ici la sortie produite par le
  compilateur de \heptagon.}.
\begin{verbatim}
for (i = 0; i < 10; i++) {
  t1[i] = !t0[i]; }
\end{verbatim}
Or, le langage VHDL dispose d'op\'erateurs agissant directement sur les
tableaux de bits (e.g., non logique, et logique). La bonne traduction
de la premi\`ere \'equation est donc:
\begin{verbatim}
t1 := not t0;
\end{verbatim}
La g\'en\'eration de ce code, si elle est triviale \`a partir du code format data-flow,
parait d\'elicate \`a partir du code imp\'eratif traduit par KCG.
\end{enumerate}

Retenons ici qu'une information pr\'ecieuse pour la g\'en\'eration
de code VHDL a \'et\'e perdue durant la compilation vers du code s\'equentiel et
doit donc \^etre reconstruite. Nous identifions trois autres
difficult\'es.
\begin{itemize}
\item La n\'ecessit\'e de certification demande d'instrumenter le
  compilateur KCG avec des informations donnant la tra\c{c}abilit\'e (lien
  entre les noms de variables produites et les noms dans le code
  source, en particulier).
\item Certaines optimisations pertinentes lorsque l'on g\'en\`ere du code
  s\'equentiel, peuvent ne pas \^etre utiles, voire p\'enalisantes, pour une
  compilation vers VHDL. C'est le cas de l'optimisation des structures
  de contr\^ole ou de la compilation des boucles (cf. discussion
  ci-dessus, conduisant \`a g\'en\'erer trop de registres).
\item Il est n\'ecessaire de restreindre le p\'erim\`etre du compilateur C
  vers VHDL: on ne r\'ealise pas un compilateur capable de traduire tout
  code C vers VHDL mais plut\^ot un compilateur adapt\'e au code C produit
  par KCG et prenant en compte la technique de compilation
  sous-jacente. Comment d\'ecrire ce p\'erim\`etre ?
\end{itemize}

Il semble enfin peu naturel de passer par un langage
  interm\'ediaire s\'equentiel (ici C) pour compiler un langage parall\`ele
  tel que \scade{} vers un langage parall\`ele tel que \vhdl. Ces divers points
ont motiv\'e la d\'efinition d'une m\'ethode de compilation directe, \`a partir d'un
code interm\'ediaire data-flow utilis\'e dans KCG.

\section{Prototypage}
Nous avons r\'ealis\'e un compilateur de r\'ef\'erence, appel\'e \LANG{}. Le
langage d'entr\'ee est un sous-ensemble de \scadesix: il permet de
combiner des \'equations de suite telles qu'\'ecrites en \lustre{} des
structures de contr\^ole (e.g., automates, conditions d'activation)
ainsi que des tableaux manipul\'es par des it\'erateurs (dans l'esprit
de~\cite{lucy:genie00,morel-07-jes}). Le langage dispose des
principales constructions de \scadesix. Certaines constructions n'ont
cependant pas \'et\'e int\'egr\'ees (e.g., signaux, \'emission sur les
transitions).

\subsection{Exemples}

Nous donnons ici quelques exemples de programmes \'ecrits dans \LANG.

\subsubsection{Compteur d'\'ev\'enements simple}

\verbatiminput{simpcount.ept}

Le noeud \textit{count} compte le nombre d'\'ev\'enements \textit{e} re\c{c}us depuis le
premier instant du programme.

\subsubsection{Compteur multi-\'ev\'enements r\'einitialisable}

\verbatiminput{compteur.ept}

Ce programme implante un compteur d'\'ev\'enements qui comptabilise le
nombre de bool\'eens valant \texttt{true} sur son entr\'ee
\textit{event}, celle-ci \'etant un tableau de bool\'eens de taille
\textit{n}, o\`u \textit{n} est un param\`etre statiquement connu du
noeud. On utilise les it\'erateurs \texttt{map} et \texttt{fold} pour
calculer le nombre d'\'ev\'enements observ\'es dans l'instant; le
premier permet de traduire les bool\'eens en entiers, et le second
d'additioner ceux-ci. Notons \'egalement l'utilisation de la
construction de r\'einitialisation \texttt{reset}, actionn\'ee
simplement lorsque l'entr\'ee \textit{rst} est vraie.

\subsubsection{Allocateur de ressource}

\verbatiminput{alloc.ept}

Cet exemple pr\'esente un automate r\'ealisant l'allocation d'une ressource
quelconque \`a deux demandeurs, avec priorit\'e \textit{round-robin} (en cas de
demande simultann\'ee, le processus qui vera sa requ\^etre satisfaite sera celui
ayant obtenu la ressource il y a le plus longtemps).

\subsection{Architecture du compilateur}

On d\'ecrit bri\`evement l'architecture du compilateur: apr\`es des
phases initiales d'analyse lexicale, syntaxique et de typage, le
programme \LANG{} est soumis aux v\'erifications traditionnelles des
langages synchrones (typage, analyse de causalit\'e, etc.). Ensuite, la compilation
progresse par \'etapes successives en r\'e\'ecrivant le programme jusqu'\`a
arriver \`a une forme simplifi\'ee data-flow \'ecrite dans un langage interm\'ediaire
appel\'e \minils. Le processus de compilation de \minils{}
vers du code s\'equentiel est d\'ecrit en d\'etails dans
l'article \cite{lucy:lctes08a}. L'architecture du compilateur \LANG{} est pr\'esent\'ee
dans la figure~\ref{fig:archi}.

% Le compilateur est structur\'e en plusieurs passes effectuant une combinaison
% d'analyses et de transformations, g\'en\'eralement dans le but d'obtenir un code
% imp\'eratif bas-niveau compilable avec les outils idoines. On d\'etaille bri\`evement
% ces diff\'erentes passes, d'abord dans le cas de la compilation traditionnelle
% (cercles verts du sch\'ema) vers un langage imp\'eratif, puis lorsque la cible est
% VHDL (cercles bleus). Les \'etapes quatre \`a sept sont d\'ecrites dans l'article
% \cite{lucy:lctes08a}.

\begin{figure}[t]
  \centering
  \includegraphics[scale=0.5]{archi}
  \caption{Architecture du compilateur \LANG}
  \label{fig:archi}
\end{figure}

Le passage au code s\'equentiel est court-circuit\'e lors d'une compilation vers
\vhdl, qui traduit \minils{} directement vers celui-ci. Pour faciliter cette \'etape,
trois simplifications sont appliqu\'ees sur le code \minils.

%\renewcommand{\labelenumi}{\Alph{enumi}}
\begin{enumerate}
\item suppression de la r\'einitialisation logique;
\item suppression des it\'erateurs par expansion de code;
\item introduction d'une variable interm\'ediaire pour chaque argument d'un appel
  de noeud.
\end{enumerate}

Le code obtenu sera finalement traduit vers un sous-ensemble de \vhdl, appel\'e
\minivhdl (\'etape D), pr\^et \`a \^etre trait\'e par les outil d\'edi\'es (\'etape E). Remarquons
qu'i n'existe pas de d\'efinition pr\'ecise identifiant un sous-ensemble
``synth\'etisable'' du langage \vhdl, g\'er\'e par les principaux outils
industriels. Apr\`es \'echange avec les partenaires du projet GENCOD,
\minivhdl{} correspond \`a un sous-ensemble raisonnable.


\section{De \LANG{} \`a VHDL}
Apr\`es avoir rappell\'e bri\`evement la forme des langages d'entr\'ee et de sortie, on
va expliciter la proc\'edure de traduction retenue.

\subsection{Langages internes}

\subsubsection{MiniLS}
\label{sec:syn:mls}

\begin{figure}[h]
  \centering
  \begin{eqnarray*}
    td & \Coloneqq & \mybox{type } bt = C + \dots + C \\
    d & \Coloneqq & \Node{p}{p}{p}{D} \\
    p & \Coloneqq & x : bt; \dots; x : bt \\
    D & \Coloneqq & pat = e; \dots; pat = e \\
    pat & \Coloneqq & x \p (pat,\dots,pat) \\
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \Fby{v}{e} \p \Pre{e} \\
    & \p & \Every{f}{e}{e}{x} \p \When{e}{C}{x} \\
    & \p & \Merge{x}{C}{e}{C}{e} \\
    & \p & \Map{f}{e_1}{e_n} \\
    & \p & \Fold{f}{e_1}{e_n} \\
    & \p & \Mapfold{f}{e_1}{e_n} \\
    v & \Coloneqq & i \p C \\
    ck & \Coloneqq & \Base \p \On{ck}{C}{x}
  \end{eqnarray*}
  \caption{MiniLS}
  \label{fig:mls}
\end{figure}

\minils{} est un langage data-flow synchrone dans l'esprit de
\lustre~\cite{lustre:ieee91}, auquel on adjoint une construction de
r\'einitialisation modulaire et d'\'ecrire des \'equations gard\'ees par une
horloge. La compilation de \minils{} vers \vhdl{} passe successivement
par trois formes distinctes.

\begin{enumerate}
\item La forme originale (dont la syntaxe est d\'efinie dans la figure~\ref{fig:mls}) telle
  qu'obtenue \`a partir du code \LANG{} original.
\item Le code est traduit vers une forme normale
  (figure~\ref{fig:mlsn}).
\item La forme finale (voir figure~\ref{fig:mlsns}) est une forme
normalis\'ee et dans laquelle les r\'einitialisations et les it\'erateurs de tableaux
ont \'et\'e \'elimin\'es. De plus, les param\`etres effectifs des appels de fonctions
sont n\'ecessairement des noms de variables.
\end{enumerate}

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \When{e}{C}{x} \\
    ce & \Coloneqq & e \p \Merge{x}{C}{ce}{C}{ce} \\
    eq & \Coloneqq & x = ce \p x = \Fby{v}{e} \p x = \Pre{e} \\
    & \p & (x,\dots,x) = \Every{f}{e}{e}{x} \\
    & \p & (x,\dots,x) = \App{f}{e,\dots,e} \\
    & \p & (x,\dots,x) = \Map{f}{e_1}{e_n} \\
    & \p & (x,\dots,x) = \Fold{f}{e_1}{e_n} \\
    & \p & (x,\dots,x) = \Mapfold{f}{e_1}{e_n}
  \end{eqnarray*}
  \caption{MiniLS normalis\'e}
  \label{fig:mlsn}
\end{figure}

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \When{e}{C}{x} \\
    ce & \Coloneqq & e \p \Merge{x}{C}{ce}{C}{ce} \\
    eq & \Coloneqq & x = \Pre{e} \\
    & \p & (x,\dots,x) = \App{f}{x,\dots,x}
  \end{eqnarray*}
  \caption{MiniLS simplifi\'e (et normalis\'e)}
  \label{fig:mlsns}
\end{figure}

\subsection{S\'emantique intuitive}
La s\'emantique de \minils{} est celle de \lustre: un noeud est compos\'e d'un ensemble
d'\'equations de suites mutuellement r\'ecursives. Discutons des points qui distinguent
le langage de \lustre:

\begin{itemize}
\item
Chaque expression $e$ est annot\'ee par une expression d'horloge $ck$. $e$ doit
\^etre calcul\'ee lorsque $ck$ est vrai. Cette annotation est produite automatiquement
par le compilateur au cours du calcul d'horloges.
\item
$\Every{f}{e_1}{e_n}{x}$ permet de r\'einitialiser l'appel de noeud $f^{ck}(e_1,...,e_n)$
lorsque $e$ est vraie.
\item
%% Les expressions simples du langage s'ex\'ecutent uniquement dans l'instant, et
%% n'ont pas d'effet en dehors de celui-ci.

%% \[
%% \begin{array}{|r|llllllllllllllllllllllllllll}
%%   \hline
%%   1     & 1 & 1 & 1 & 1 & \dots \\
%%   \hline
%%   1 + 2 & 3 & 3 & 3 & 3 & \dots \\
%%   \hline
%% \end{array}
%% \]

%% \`A l'inverse, les expressions \textrm{pre} et \textrm{fby} permettent de retarder
%% leur argument d'un instant, avec une valeur d'initialisation dans le cas de
%% \textrm{fby}.

%% \[
%% \begin{array}{|r|llllllllllllllllllllllllllll}
%%   \hline
%%   1 \ \mathrm{fby} \ 2 & 1 & 2 & 2 & 2 & \dots \\
%%   \hline
%%   \mathrm{pre} \ 3 &  & 3 & 3 & 3 & \dots \\
%%   \hline
%% \end{array}
%% \]
Les expressions \texttt{when} et \texttt{merge} permettent respectivement de
sous-\'echantilloner et sur-\'echantilloner des expressions. L'emploi de ces
constructions a un effet sur les horloges: l'horloge de $\When{e}{C}{x}$ est
$\On{ck}{C}{x}$, o\`u $ck$ est celle de $e$, et l'horloge de
$\Merge{x}{C_1}{e_1}{C_n}{e_n}$ est $ck$ quand celle des $e_i$ est
$\On{ck}{C}{x}$. L'expression $\On{ck}{C}{x}$ indique que le r\'esultat est
pr\'esent lorsque l'horloge $ck$ est vraie et que $x$ est \'egal \`a $C$.

\[
\begin{array}{|r|llllllllllllllllllllllllllll}
  \hline
  x & 1 & 2 & 3 & 4 & \dots \\
  \hline
  h & false & true & false & true & \dots \\
  \hline
  \When{x}{true}{h} & & 2 & & 4 & \dots \\
  \hline
  u &  & 1 & & 4 & \dots \\
  \hline
  v & 0 & & 3 & & \dots \\
  \hline
  \Merges{h}{true}{u}{false}{v} & 0 & 1 & 3 & 4 \\
  \hline
\end{array}
\]

\item
Les it\'erateurs \texttt{map}, \texttt{fold}, et \texttt{mapfold}
prennent en argument une fonction $f$, une taille de tableau et un ou
plusieurs tableaux. La s\'emantique de ces constructions est celle
donn\'ee dans~\cite{lucy:genie00,morel-07-jes}.

\begin{itemize}
\item \texttt{map} applique en parall\`ele $f$ \`a tous les \'el\'ements des tableaux
  pour former un nouveau tableau.
\item \texttt{fold} applique en s\'erie $f$ sur tous les \'el\'ements d'un tableau en
  passant un accumulateur et renvoie ce dernier une fois le parcours termin\'e.
\item \texttt{mapfold}, qui suppose que $f$ renvoie au moins deux valeurs,
  combine les deux en construisant un nouveau tableau avec le premier r\'esultat
  de $f$ (\`a la mani\`ere de \texttt{map}) et en passant un accumulateur durant le
  parcours (tout comme \texttt{fold}).
\end{itemize}
\end{itemize}

\subsubsection{MiniVHDL}

\minivhdl{} (d\'efini dans la figure~\ref{fig:mvhdl})
est un fragment de \vhdl{} suffisant pour
d\'ecrire l'essence du processus de traduction. Un composant \minivhdl:
\[
\Component{f}{P}{sigs}{lvars}{ports}{I}
\]
correspond \`a un
composant \vhdl{} form\'e des instantiations $ports$, signaux internes $sigs$ et d'un
processus avec les variables locales $lvars$ et de corps $I$.

Le langage est structur\'e sous forme de composants. Chacun d'eux poss\`ede des
signaux d'entr\'ee et de sortie, des signaux locaux, des variables locales, d'\'eventuels
sous-composants, et enfin un corps form\'e d'une suite d'instructions.

La s\'emantique informelle du langage est la suivante: d\`es que la valeur d'un
signal d'entr\'ee ou local change, le corps du composant est ex\'ecut\'e. Celui-ci
peut modifier la valeur d'autres signaux via l'instruction $x \Leftarrow e$ ($x$
\'etant par d\'efinition un signal), entra\^{\i}nant ainsi l'activation de
sous-composants, ou m\^eme la r\'eactivation du composant courant. Les variables
locales sont semblables aux variables des langages de programmation
traditionnels: elles n'ont de valeur que pendant l'ex\'ecution du corps d'un
composant. L'ex\'ecution s'arr\^ete une fois tous les signaux stables.

\begin{figure}[t]
  \centering
  \begin{eqnarray*}
    component & \Coloneqq & \mybox{component} \; f \; \mybox{port} \; sm;\dots;\
    sm \; \mybox{with} \, \mybox{sig} \; d; \dots; d \; \\
    & & \mybox{and} \, \mybox{var} \; d; \dots; d \; \mybox{and} \
    \mybox{subcomponents} \; p; \dots; p \; \mybox{in} \; I \\
    sm & \Coloneqq & x : mode \ ty \\
    sd & \Coloneqq & x : mode \ ty := e \\
    mode & \Coloneqq & \mybox{in} \p \mybox{out} \\
    d & \Coloneqq & x : ty \\
    p & \Coloneqq & \mybox{port map } x (bd;\dots;bd) \\
    bd & \Coloneqq & x \Rightarrow x \\
    I & \coloneqq & i; \dots; i \\
    i & \Coloneqq & \Assign{x}{e} \p \Affect{x}{e} \p \Case{e}{v}{I}{v}{I} \\
    e & \Coloneqq & id \; \vert \; v \; \vert \; \Op{e}{e} \\
    v & \Coloneqq & i \; \vert \; ' bitp ' \\
    bitp & \Coloneqq & bit \p bit \  bitp \\
    bit & \Coloneqq & \mathbf{0} \p \mathbf{1} \\
    bt & \Coloneqq & \mybox{natural} \p \mybox{std\_logic} \p \mybox{bit}
    \p \dots
  \end{eqnarray*}
  \caption{MiniVHDL}
  \label{fig:mvhdl}
\end{figure}

Notons que les param\`etres effectifs des sous-composants sont des noms de
signaux; cela justifie la forme simplifi\'ee \minils{} d\'ecrite pr\'ec\'edemment.

\subsection{Simplification de MiniLS normalis\'e}

Nous effectuons donc trois passes pour simplifier le code \minils.

\subsubsection{\'Elimination de la r\'einitialisation logique}

Comme expliqu\'e plus haut, certaines constructions de MiniLS proposent au
programmeur une forme de r\'einitialisation modulaire : les \'equations de la
forme $\Fby{v}{e}$ d'un noeud $f$ instanci\'e par la construction
$\Every{f}{e_1}{e_n}{z}$ doivent-\^etre r\'einitialis\'ees d\`es lors que $z$
est vrai.

La premi\`ere passe de simplification, qui s'ex\'ecute sur le code MiniLS obtenu
\`a la troisi\`eme \'etape du processus d\'ecrit plus haut, va exprimer la
r\'einitialisation en fonction du reste du langage, r\'eduisant ainsi la complexit\'e
du langage \`a traduire vers VHDL.

On va supposer dans ce qui suit que l'identifiant \textbf{rst} est un
identifiant utilis\'e nulle part dans le programme. En pratique, le compilateur
s'assure de l'absence de conflit avec les variables de l'utilisateur.

L'id\'ee est d'ajouter \`a chaque noeud un argument suppl\'ementaire nomm\'e
\textbf{rst} qui vaudra $true$ lorsqu'une r\'einitialisation de la m\'emoire est
n\'ecessaire, et de modifier les expressions contenant des constructions
\texttt{fby} ou \texttt{every} pour prendre en compte \textbf{rst}. L'exemple
suivant reprend le compteur simple pr\'esent\'e plus haut pour illustrer cette
simplification.

\verbatiminput{rst_ex.ept}

Une fois le reset \'elimin\'e, le code est le suivant :

\verbatiminput{rst_ex2.ept}

On va d\'etailler les fonctions effectuant ces deux t\^aches : $RstE(e)$ prend une
expression MiniLS $e$ et renvoie une nouvelle expression o\`u la r\'einitialisation
a \'et\'e \'elimin\'ee, et $RstNode(nd)$ prend un nœud $nd$ et renvoie un nouveau nœud
prenant un \texttt{rst} \`a un noeud et transforme ses \'equations.

\newcommand{\re}[1]{RstE(#1)}
\newcommand{\rstn}[1]{RstNode(#1)}

\[
\begin{array}{lcl}
  \re{\Op{e_1}{e_n}} & = & \Op{\re{e_1}}{\re{e_n}} \\
  \re{\Fby{v}{e}} & = & \If{rst}{v}{(\Fby{v}{\re{e}})} \\
  \re{\Pre{e}} & = & \Pre{\re{e}} \\
  \re{\Every{f}{e_1}{e_n}{x}} & = & \App{f}{\mathbf{rst} \; \mathtt{or} \;
    x, \re{e_1} \dots, \re{e_n}} \\
  \re{\App{f}{e_1,\dots,e_n}} & = &
  \App{f}{\mathbf{rst},\re{e_1},\dots,\re{e_n}} \\
  \re{\If{e_1}{e_2}{e_3}} & = & \If{\re{e_1}}{\re{e_2}\\ & & \hspace{1.9cm}}
  {\re{e_3}} \\
  \re{\When{e}{C}{x}} & = & \When{\re{e}}{C}{x} \\
  \re{\Merge{e}{C_1}{e_1}{C_n}{e_n}} & = &
  \mybox{merge} \; \re{e} \; (C_1 \Rightarrow \re{e_1}) \\
  & & \hspace{2.4cm} \dots \\
  & & \hspace{2.4cm} (C_n \Rightarrow \re{e_n})
\\ \\
RstEqs(pat_1 = e_1;\dots;pat_n = e_n) & = &
  pat_1 = \re{e_1};\dots;pat_n = \re{e_n} \\
  \end{array}
\]

\[
\begin{array}{ll}
  \rstn{\Node{f}{x_1,\dots,x_n}{y_1,\dots,y_n}{eqs}} & = \\
  \ind \Node{f}{rst,x_1,\dots,x_n}{y_1,\dots,y_n}{ResetEqs(eqs)}
\end{array}
\]

\subsubsection{Suppression des it\'erateurs}

La version actuelle du compilateur et de son g\'en\'erateur de code VHDL supporte
les tableaux de dimension arbitraire \footnote{En pratique, les outils de
  synth\`ese de circuits \`a partir de code VHDL imposent une dimension maximale.}
et constructions associ\'ees ; il nous faut donc compiler les it\'erateurs
\texttt{map}, \texttt{fold} et \texttt{mapfold} vers VHDL.

Par souci de simplicit\'e et uniformit\'e, nous avons fait le choix de les \'eliminer
par \textit{inlining} lors d'une transformation source-\`a-source sur MiniLS. On
ne d\'etaillera pas cette op\'eration qui consiste simplement \`a remplacer les
it\'erateurs par plusieurs \'equations. L'\'equation $x = \Map{f}{t_1}{t_m}$ lorsque
les tableaux $t_1, \dots, t_m$ sont de taille $n$ sera ainsi remplac\'ee par $n +
1$ \'equations dont les $n$ premi\`eres effectuent l'application de $f$ pour chaque
indice et la derni\`ere affecte \`a $x$ le tableau en r\'esultant. On applique des
transformations similaires aux op\'erateurs \texttt{fold} et \texttt{mapfold}.

Le programme suivant pr\'esente un exemple effectuant un ET logique sur tous les
\'el\'ements d'un tableau via l'it\'erateur \texttt{fold}.

\verbatiminput{fold_orig.ept}

Son pendant avec it\'erateur mis \`a plat se contente de passer l'accumulateur
d'\'el\'ement en \'el\'ement.

\verbatiminput{fold_il.ept}

Un traitement sp\'ecial est adopt\'e pour l'utilisation de \texttt{map} avec
certains op\'erateurs. En effet, VHDL permet d'utiliser certains op\'erateurs sur
des tableaux de bits, sans avoir \`a d\'econstruire ces derniers ; par exemple, il
est possible d'effectuer un ET logique bit-\`a-bit sur deux tableaux $t_1$ et
$t_2$ via $t_1 \ \texttt{and} \ t_2$. La passe effectue la transformation de
$\texttt{map}\ \textbf{op}<<n>>(t_1,\dots,t_n)$ \`a $t_1\ \textbf{op}\ \dots
\textbf{op}\ t_n$ lorsque cela est possible.

\subsubsection{Simplification des appels}

\newcommand{\simpl}[2]{Simpl(#1,#2)}
\newcommand{\simplnd}[1]{SimplNode(#1)}

Comme nous le verrons plus bas, les appels de nœuds seront compil\'es en
instantiations de composants ; or, les arguments d'une construction VHDL $port
\; map$ sont forc\'ement des identifiants. Pour simplifier la g\'en\'eration de
VHDL, on va donc modifier en amont chaque appel de noeud en introduisant une
variable interm\'ediaire pour chaque argument. La fonction $\simpl{eq}{eqs}$
simplifie l'\'equation $eq$ en ajoutant la ou les \'equations produits \`a la liste
des \'equations d\'ej\`a trait\'ees $eqs$ ; $\simplnd{nd}$ prend un noeud $nd$ et
simplifie les appels pr\'esents dans ses \'equations.

\[
\begin{array}{ll}
  \simpl{x = ce}{eqs} & = \\
  \ind (x = ce) \Cons eqs \\
  \simpl{x = \Pre{e}}{eqs} & = \\
  \ind (x = \Pre{e}) \Cons eqs \\

  \simpl{(x_1,\dots,x_n) = \App{f}{e_1,\dots,e_n}}{eqs} & = \\
  \ind (y_1 = e_1) \Cons \dots \Cons (y_n = e_n)
  \Cons ((x_1,\dots,x_n) = \App{f}{rst,y_1,\dots,y_n}) \Cons eqs \\
  \ind \mbox{o\`u } y_1,\dots,y_n \mbox{ sont des noms de variables frais}
\end{array}
\]

\[
\begin{array}{ll}
  \simplnd{\Node{x_1,\dots,x_n}{y_1,\dots,y_n}{p}{D}} & = \\
  \ind \mathtt{node} f(x_1,\dots,x_n) = y_1, \dots, y_n \; \\
  \ind \mathtt{with} \  \mathtt{var} \; p' \; \mathtt{in} \; fold\_right \;Simpl
  \; D \; [] \\
  \ind \mbox{en supposant que $p'$ correspond
             aux variables d\'efinies par} \\ \ind \mbox{les nouvelles \'equations.}
\end{array}
\]

Ces simplifications effectu\'ees, le programme r\'esultant est traduit vers \minivhdl.

\subsection{MiniLS simplif\'e vers MiniVHDL}

Le principe g\'en\'eral de la traduction de MiniLS simplifi\'e vers MiniVHDL est le
suivant:

\begin{enumerate}
\item Chaque noeud MiniLS correspondra \`a un composant (Mini)VHDL.
\item Chaque \'equation \`a m\'emoire (i.e. contenant $fby$ ou $pre$) va correspondre
  \`a un signal VHDL local, chaque \'equation combinatoire \`a une variable locale.
\item Les horloges importent uniquement pour les \'equations de la forme $x =
  \Fby{v}{e}$ et $(x_1,\dots,x_n) = \App{f}{e_1,\dots,e_n}$ : il faudra alors
  g\'en\'erer la garde bool\'eenne correspondant \`a $ck$. Les autres sont combinatoires
  et ne n\'ecessitent pas de traitement particulier.
\item La r\'einitialisation logique est g\'er\'ee en amont comme expliqu\'ee ci-dessus,
  elle est donc implicitement asynchrone (ind\'ependante des fronts montants de
  l'horloge).
\item Les partenaires ont exprim\'e le d\'esir de pouvoir r\'einitialiser
  physiquement toute la m\'emoire lors du bascument d'un signal pr\'ecis
  nomm\'e \textbf{hwrst} : on ajoute donc ce signal suppl\'ementaire
  invisible dans le code MiniLS et on g\'en\`ere le code de
  r\'einitialisation correspondant lors du traitement du $fby$. Tout
  comme pour l'identifiant \textit{rst} plus haut, on suppose que
  l'identifiant \textbf{hwrst} n'est pas utilis\'e dans le programme.
\item Pour respecter la s\'emantique \`a $\Delta$-cycles de VHDL, il importe de
  faire \'evoluer la m\'emoire par un pas du calcul uniquement sur front montant de
  l'horloge.
\item En suivant le mod\`ele synchrone, les valeurs calcul\'ees par le circuit \`a
  d'autres moments que le front montant n'ont pas de sens bien d\'efini ; on les
  ignorera donc.
\item Chaque appel de noeud correspondra \`a une instantiation. Comme sp\'ecifi\'e
  plus haut, les param\`etres effectifs d'un signal VHDL sont obligatoirement des
  signaux auxquels il faudra assigner la valeur correcte.
\end{enumerate}

\subsubsection{Traduction des types}

Les d\'eclarations de types de donn\'ees ont \'et\'e laiss\'ees implicites aussi bien dans
la syntaxe de MiniLS que de MiniVHDL ; les possibilit\'es \'etant exactement les
m\^emes (\'enum\'erations et enregistrements), on choisit de ne pas s'attarder sur
leur traduction qui reste une traduction mot-\`a-mot d'une syntaxe concr\`ete \`a
l'autre.

\subsubsection{Traduction des constantes et fonction auxiliaires sur les horloges}

La fonction $TradConst(c)$ traduit une constante MiniLS $c$ en constante
MiniVHDL.

\newcommand{\TradC}[1]{TradConst(#1)}

\[
\begin{array}{lcl}
  \TradC{i} & = & i \\
  \TradC{true} & = & '1' \\
  \TradC{false} & = & '0' \\
  \TradC{C} & = & C
\end{array}
\]

La fonction auxiliaire $GuardClock$ permet de traduire une horloge MiniLS en
expression MiniVHDL de type bool\'een. Elle sera utilis\'ee pour contr\^oler la
mise \`a jour des registres, s'assurant que cette derni\`ere n'est effectu\'ee
qu'aux instants o\`u l'horloge est effective.

\newcommand{\GEC}[1]{GuardClock(#1)}

\[
\begin{array}{lcl}
  \GEC{\Base} & = & rising\_edge(clk) \\
  \GEC{\On{ck}{C}{x}} & = & x = \TradC{C} \; \mathtt{and} \; \GEC{ck}
\end{array}
\]

Tout comme les mises \`a jour des m\'emoires, les appels \`a d'autres noeuds
sont dirig\'es par les horloges qui en donnent la cadence. Il nous faudra donc
une fonction voisine de $GuardClock$ pour calculer l'expression MiniVHDL
correspondant \`a l'horloge utilis\'ee dans l'appel d'un noeud.

\newcommand{\EC}[1]{ExpClock(#1)}

\[
\begin{array}{lcl}
  \EC{\Base} & = & clk \\
  \EC{\On{ck}{C}{x}} & = & x = \TradC{C} \; \mathtt{and} \; \EC{ck}
\end{array}
\]

\subsubsection{Traduction des expressions et \'equations}

La fonction $TradExp(e)$ traduit l'expression MiniLS normalis\'ee et
simplifi\'e $e$ en expression MiniVHDL.

\newcommand{\TradE}[1]{TradExp(#1)}

\[
\begin{array}{lcl}
  \TradE{v} & = & \TradC{v} \\
  \TradE{x} & = & x \\
  \TradE{\Op{e_1}{e_n}} & = & \Op{\TradE{e_1}}{\TradE{e_n}} \\
  \TradE{\When{e}{C}{x}} & = & \TradE{e}
\end{array}
\]

La construction \texttt{when} n'a pas de sens calculatoire, et peut n'\^etre vue
que comme une annotation d'horloge. Elle sera ignor\'ee lors du processus de
traduction.

La fonction $TradCExp(ce)$ traduit les expressions $ce$ de contr\^ole form\'ees
d'expressions simples ou de \texttt{merge} imbriqu\'es en instructions MiniVHDL.

\newcommand{\TradCE}[2]{TradCExp(#1, #2)}

\[
\begin{array}{ll}
  \TradCE{x}{\Merge{y}{C_1}{ce_1}{C_n}{ce_n}} & = \\
  \ind \mathtt{case} \; y \; \mathtt{of} \;
  (\TradC{C_1} \Rightarrow \TradCE{x}{ce_1}) \\
  \hspace{2.1cm} \dots \\
  \hspace{2.1cm} (\TradC{C_n} \Rightarrow \TradCE{x}{ce_n}) \\
  \TradCE{x}{e} & = \\
  \ind \Affect{x}{\TradE{e}}
\end{array}
\]

Enfin, la fonction $TradEq$ permet de passer des \'equations aux instructions
MiniVHDL. Elle prend un argument suppl\'ementaire permettant de compter le nombre
d'appels de noeuds afin de g\'en\'erer des arguments suppl\'ementaires, et on se donne
une fonction suppl\'ementaire $MakeArg(x,i)$ qui g\'en\`ere un nom de variable frais \`a
partir du nom de variable $x$ et de l'entier $i$.

La traduction des \'equations appelant un noeud n\'ecessite des explications
concernant la fa\c{c}on de compiler les appels d'un noeud MiniLS qui seront donn\'ees
\`a la section suivante.

\newcommand{\TradEq}[2]{TradEq(#1,#2)}
\newcommand{\MA}[2]{MakeArg(#1,#2)}

\[
\begin{array}{lcl}
  \TradEq{x = ce}{i} & = & \TradCE{x}{ce}, i \\

  \TradEq{x = \Pre{e}}{i} & = & \mathtt{if} \; \GEC{ck} \; \mathtt{then} \\
  & & \ind \Assign{x}{\TradE{e}} \\
  & & \mathtt{end} \; \mathtt{if}, i \\

  \TradEq{x = \Fby{y}{e}}{i} & = & \mathtt{if} \; \mathbf{hwrst}
  \; \mathtt{then} \\
  & & \ind \Assign{x}{y} \\
  & & \mathtt{elsif} \; \GEC{ck} \; \mathtt{then} \\
  & & \ind \Assign{x}{\TradE{e}} \\
  & & \mathtt{end} \; \mathtt{if}, i \\


  \TradEq{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}}{n} & = &
  \Assign{\MA{"ck"}{i}}{\EC{ck}} \\
  & & \Assign{\MA{y_1}{i}}{y_1} \\
  & & \dots \\
  & & \Assign{\MA{y_n}{i}}{y_n}, i + 1 \\
\end{array}
\]

Pr\'ecisons que par construction, l'interface d'un composant suit toujours la
forme suivante:
\[(clk, hwrst, in_1, \dots,in_n, out_1,\dots,out_n)
\]
Rappelons que le reset ``logique'' (celui utilis\'e dans les automates, par exemple
ou la construction \verb-every-) est maintenant une entr\'ee suppl\'ementaire (ici $in_1$).

\subsubsection{Gestion des tableaux}

Hormis le cas des it\'erateurs trait\'es pr\'ec\'edemment, la gestion des
tableaux n'appelle pas de commentaire particulier, \`a l'exception de la
n\'ecessit\'e de d\'eclarer \`a l'avance les types tableaux (bornes exclues) en
VHDL. Deux solutions sont envisageables:

\begin{itemize}
\item Calculer la dimension maximale des tableaux rencontr\'es dans le programme,
  et utiliser cette information pour pr\'e-d\'eclarer les tableaux VHDL idoines.
\item D\'eclarer quoi qu'il advienne les types de tableaux utiles et refuser les
  programmes comprenant des dimensions sup\'erieures \`a une limite fix\'ee \`a l'avance.
\end{itemize}

Le compilateur emploie pour l'instant la premi\`ere m\'ethode mais la seconde ne
nous semble pas d\'erangeante pour des raisons pragmatiques~\footnote{Notons que
  notre version de l'outil Xilinx ISE refuse tout tableau de
  dimension sup\'erieure \`a trois.}.

\subsubsection{Compilation modulaire et appels de noeuds}

MiniVHDL offre une forme de modularit\'e bas\'ee sur une hi\'erarchie de
composants. Chacun de ces derniers sp\'ecifie une liste de composants fils dont
les ports (au sens de la figure \ref{fig:mvhdl}) sont instanci\'es avec des
signaux. Nous prenons donc soin d'utiliser des signaux comme r\'esultats mais
aussi arguments ; par souci de simplicit\'e, on introduit des signaux locaux pour
chaque argument, signaux qui seront affect\'es lors de la traduction de l'\'equation
correspondant \`a l'appel de noeud original.

La fonction $GatherPortMaps(D, i)$ rassemble cette liste de sous-noeuds \`a partir
des appels de noeud pr\'esents dans le paquet d'\'equations $D$ et cr\'e\'e les
instantiations de composants correspondantes. L'entier $i$ nous servira \`a
distinguer les appels de noeuds et de cr\'eer de nouveaux noms de signaux frais
gr\^ace \`a la fonction $MakeArg$ d\'ecrite plus haut. On se donne \'egalement une
fonction $GetArgName(f,n)$ qui renvoie le nom du $n$-\`eme argument du noeud de
nom $f$.

\newcommand{\GPM}[2]{GatherPortMaps(#1,#2)}
\newcommand{\GAN}[2]{GetArgName(#1,#2)}

\[
\begin{array}{lcl}
  \GPM{[]}{i} & = & [] \\
  \GPM{((x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}) \Cons eqs}{i} & = &
  \\
  \ind \mybox{port map} \; f ( clk \Rightarrow \MA{"clk"}{i} \\
  \ind \ind \ind \ind \hspace{0.4cm} \GAN{f}{1} \Rightarrow \MA{y_1}{i} \\
  \ind \ind \ind \ind \hspace{0.4cm} \dots \\
  \ind \ind \ind \ind \hspace{0.4cm} \GAN{f}{n} \Rightarrow \MA{y_n}{i}) \\
  \ind \Cons \GPM{eqs}{i + 1}
\end{array}
\]

On d\'efinit ensuite les fonctions auxiliaires $NeedVar$, $Vars$, $ParamSigs$ et
$SignalOfVarDec$ respectivement charg\'ees de d\'eterminer si une \'equation introduit
des d\'eclarations de variables locales ou non, de calculer la liste des variables
d\'efinies par une \'equation, de calculer les signaux \`a passer en arguments aux
appels de noeuds pr\'esents dans un paquet d'\'equations et enfin de traduire
simplement une d\'eclaration de variable MiniLS en d\'eclaration de signal MiniVHDL
avec mode d'utilisation (entr\'ee ou sortie).

\newcommand{\NV}[1]{NeedVar(#1)}
\newcommand{\V}[1]{Vars(#1)}
\newcommand{\PS}[2]{ParamSigs(#1,#2)}
\newcommand{\SoVD}[3]{SignalOfVarDec(#1 : #2, #3)}

\[
\begin{array}{lcl}
  \NV{x = \Fby{v}{e}} & = & false \\
  \NV{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}} & = & false \\
  \NV{x = ce} & = & true
\end{array}
\]

\[
\begin{array}{lcl}
  \V{x = \Fby{v}{e}} & = & [x] \\
  \V{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}} & = & x_1 \Cons \dots \Cons x_n \\
  \V{x = ce} & = & [x]
\end{array}
\]

\[
\begin{array}{ll}
  \PS{x = \Fby{v}{e} \Cons eqs}{i} & = \\
  \ind \PS{eqs}{i} \\
  \PS{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n} \Cons eqs}{i} & = \\
  \ind \MA{"clk"}{i} \Cons \MA{y_1}{i} \Cons \dots \Cons \MA{y_n}{i} \\
  \ind \mathtt{::} \; \PS{eqs}{i + 1}
  \\
  \PS{x = ce \Cons eqs}{i} & = \\
  \ind \PS{eqs}{i}
\end{array}
\]

\[
\begin{array}[lcl]{lcl}
  \SoVD{x}{bt}{mode} & = & \mybox{signal} \; x : mode \; TransBaseType(bt)
\end{array}
\]

\subsubsection{Traduction des noeuds}

Enfin, $TradNode(nd)$ se charge de traduire un noeud $nd$ en composant MiniVHDL, en
cr\'eant un signal local pour chaque \'equation retard\'ee et argument d'appel de
noeud, une variable pour chaque \'equation combinatoire, et la liste de
sous-composants requise.

\begin{align*}
  & TradNode(\mybox{node } f(in) = out \mybox{ with var } p \mybox{ in } D) = \\
  & \bl \mbox{soit } port = \\
  & \bl \bl clk : \mybox{in std\_logic}; \\
  & \bl \bl \{ SignalOfVarDec(x : bt, \mybox{in}) \p (x : bt) \in in \}; \\
  & \bl \bl \{ SignalOfVarDec(x : bt, \mybox{out}) \p (x : bt) \in out \}, \\
  & \bl \mbox{ soit } signals = \{ \V{eq} \p eq \in D, \neg \NV{eq} \}
  \mybox{,} \\
  & \bl \mbox{ soit } sig\_args = \PS{D}{1} \mybox{,} \\
  & \bl \mbox{ soit } variables = \{ \V{eq} \p eq \in D, \NV{eq} \} \mybox{,} \\
  & \bl \mbox{ soit } ports = \GPM{D}{1} \mybox{,} \\
  & \bl \mbox{ soit } body = fold\_right TradEq D ([], 1) \mbox{ dans} \\
  & \mybox{component } f \mybox{ port } port \mybox{ with sig } signals \cup
  sig\_args \\
  & \mybox{and var } variables \mybox{ and subcomponents } ports \mybox{ in }
  body
\end{align*}

\section{Conclusion}

Ce document d\'ecrit les \'etapes de traduction d'un langage proche de
\scade{} vers un sous-ensemble de \vhdl. Le processus s'applique
directement sur un format interm\'ediaire data-flow. Le code charg\'e de la traduction
de \minils{} vers \minivhdl{} est court (de l'ordre de 600 lignes de code Ocaml).
Notons que le compilateur r\'ealis\'e est capable d'assurer le retour au source (tra\c{c}abilit\'e)
depuis le code \LANG{} (conservation des noms des identificateurs et de leur renommage
au cours des \'etapes de compilation).

Plusieurs exemples fournis par les membres du projet ont \'et\'e exp\'eriment\'es. L'efficacit\'e
du code obtenu semble comparable au code produit par Geensoft. Une exp\'erience plus
pouss\'ee pourrait \^etre men\'ee \`a l'avenir. 

\newpage
\tableofcontents

\newpage
\bibliographystyle{plain}
\bibliography{lucy,synchrone,biblio}

\newpage
\appendix


\section{Exemples de code g\'en\'er\'e}

On pr\'esente ici quelques codes g\'en\'er\'es par notre prototype. En l'\'etat
actuel de ce dernier, beaucoup de variables interm\'ediaires inutiles sont
g\'en\'er\'ees ; cela s'explique pour deux raisons :

\begin{itemize}
\item Ces codes repr\'esentent des sorties brutes n'ayant subies aucune
  optimisation.
\item Certaines passes du compilateur ont naturellement tendance \`a introduire
  des variables interm\'ediaire de fa\c{c}on pr\'eventive, simplifiant ainsi leur
  fonctionnement.
\end{itemize}

\subsection{Compteur}

\paragraph{MiniLS initial}

\small
\verbatiminput{compteur2_init.mls}
\normalsize

\paragraph{MiniLS normalis\'e, ordonnanc\'e et simplifi\'e}

Notons que le noeud \textit{compteur} est ici instanci\'e avec son param\`etre
\textit{n} \'egal \`a 4, ceci afin de pouvoir d\'eplier les it\'erateurs.

\small
\verbatiminput{compteur2_sched.mls}
\normalsize

\paragraph{VHDL}

\small
\verbatiminput{compteur2_vhdl.vhd}
\normalsize

\subsection{Allocateur de ressource}

\paragraph{MiniLS initial}

\small
\verbatiminput{al2_init.mls}
\normalsize

\paragraph{MiniLS normalis\'e, ordonnanc\'e et simplifi\'e}

\small
\verbatiminput{al2_sched.mls}
\normalsize

\paragraph{VHDL}

\small
\verbatiminput{al2_vhdl.vhd}
\normalsize

\section{Utilisation du compilateur}

Nous supposerons dans ce manuel que l'archive du compilateur a \'et\'e
d\'ecompress\'ee dans le r\'epertoire \verb/$HEPTDIR/. Cette archive contient le
pr\'esent rapport, un r\'epertoire \texttt{exs/} avec une batterie d'exemples
\LANG{} compil\'es vers VHDL, et un binaire en code-octet pour la machine
abstraite OCaml. Ce dernier peut-\^etre ex\'ecut\'e via \texttt{ocamlrun heptc},
ou bien directement lorsque votre \texttt{ocamlrun} est pr\'esent dans
\texttt{/usr/bin}. Nous supposerons par la suite que c'est le cas et que votre
variable d'environnement \verb/$PATH/ contient \verb/$HEPTDIR//bin.

Pour utiliser le compilateur, il faut tout d'abord renseigner la variable
d'environnement \verb/$HEPTLIB/ sp\'ecifiant au compilateur o\`u trouver la
biblioth\`eque standard.

\begin{verbatim}
$ export HEPTLIB=$HEPTDIR/lib
\end{verbatim}

Vous pouvez ensuite v\'erifier que le compilateur est disponible et fonctionnel
via la commande suivante :

\begin{verbatim}
$ heptc -version
The Heptagon compiler, version 0.4 (wed. aug. 18 11:17:42 CET 2010)
Standard library in [...]
\end{verbatim}

Pour compiler un fichier \LANG, le compilateur doit \^etre invoqu\'e avec l'option
\verb/-target/. Les arguments possibles pour cette option sont :

\begin{itemize}
\item \verb/vhdl/ : g\'en\`ere du code VHDL.
\item \verb/mls/ : g\'en\`ere le code \`a flots de donn\'ees MiniLS interm\'ediaire.
\item \verb/obc/ : g\'en\`ere un code imp\'eratif simple dans le langage id\'ealis\'e Obc.
\item \verb/c/ : g\'en\`ere du code C.
\end{itemize}

Les cibles VHDL et C invoqu\'ees sur un fichier \verb/source.ept/ produisent
respectivement un dossier \verb/source_vhdl/ et \verb/source_c/ qui contiennent
les fichiers sources g\'en\'er\'es. Par exemple :

\begin{verbatim}
$ cat source.ept
node main() returns (o : int)
let
  o = 0 fby (o + 1);
tel
$ heptc -target vhdl source.ept
$ ls source_vhdl
main.vhd  types.vhd
\end{verbatim}

L'option \verb/-s noeud/ permet de g\'en\`erer le code n\'ecessaire \`a un
ex\'ecutable autonome \`a partir d'un fichier source \LANG, c'est \`a dire un
\textit{test-bench} dans le cas de VHDL et une fonction \verb/main()/ en ce qui
concerne C. Voici un exemple d'utilisation de la sortie C :

\begin{verbatim}
$ cat source.ept
node noeud() returns (o : int)
let
  o = 0 fby (o + 1);
tel

node main() returns (o : int)
let
  o = noeud() + 1;
tel
$ heptc -target c -s main source.ept
$ ls source_c
_main.c  _main.h  source.c  source.h  source_types.c  source_types.h
$ cc -Isource_c source_c/*.c -o source
$ ./source 5 # Option indiquant a l'executable genere de s'arreter apres 5 pas
=> 1
=> 2
=> 3
=> 4
=> 5
\end{verbatim}

\section{Grammaire de \LANG}

Cette grammaire de r\'ef\'erence explicite la syntaxe du langage Heptagon.

\newcommand{\sdash}{\mbox{-}}
\newcommand{\spow}{\text{\^{ }}}
\newcommand{\piquots}[1]{<<#1>>}

\newcommand{\lp}{\texttt{(}}
\newcommand{\rp}{\texttt{)}}
\newcommand{\lcb}{\texttt{\{}}
\newcommand{\rcb}{\texttt{\}}}

\[
\begin{array}{lcl}
  type & \Coloneqq & \mathtt{int} \p \mathtt{bool} \p \mathtt{float} \p
    {\bf type\sdash{}name} \\
  & | & type \spow{} constant \\

  \\

  constant & \Coloneqq & {\bf constant\sdash{}name} \\
  & | & {\bf integer} \\
  & | & {\bf string} \\
  & | & constant + constant \\
  & | & constant - constant \\
  & | & \dots \\

  \\

  expression & \Coloneqq & constant \\
  & | & {\bf variable\sdash{}name} \\
  & | & expression + expression \p expression - expression \p \dots \\
  & | &
    iterator \  \lp{}iterator\sdash{}argument\rp{}
    \piquots{constant} \lp{}expression^+\rp{}
    \\
  & | &
    {\bf function\sdash{}name} \; static\sdash{}parameters \;
    \lp{}expression,\dots,expression\rp{} \\
  & | & \mathtt{last} \  {\bf variable\sdash{}name} \\
  & | & \mathtt{pre} \  expression \\
  & | & constant \  \mathtt{fby} \  expression \\
  & | & expression \  \texttt{->} \  expression \\
  & | & \lp{}expression,\dots,\ expression\rp{} \\
  & | & expression = expression \\
  & | & \mathtt{if} \ expression \ \mathtt{then} \ expression \ 
    \mathtt{else} \ expression \\
  & | & \lcb{} field\sdash{}def^+ \rcb{} \\
  & | & expression.{\bf field\sdash{}name} \\
  & | & \lcb{} expression
    \ \mathtt{with} \  field\sdash{}def^+ \rcb{} \\
  & | & [ expression, \dots, expression ] \\
  & | & expression \spow{} constant \\
  & | & expression.[constant^+] \\
  & | & expression.[constant \  .. \ constant] \\
  & | & expression.[expression^+] \ \mathtt{default} \  expression \\
  & | & [ expression \ \mathtt{with} \ expression^+ \ = \ expression ] \\
  & | & expression \ @ \ expression \\

  \\

  static\sdash{}parameters & \Coloneqq & \epsilon \\
  & | & \piquots{constant,\dots,constant} \\

  \\

  iterator & \Coloneqq & \mathtt{map} \p \mathtt{fold} \p \mathtt{mapfold} \\
  iterator\sdash{}argument & \Coloneqq &
    {\bf function\sdash{}name} \; static\sdash{}parameters
    \p \mathtt{+} \p \mathtt{-} \p \dots \\

  \\

  field\sdash{}def & \Coloneqq & {\bf field\sdash{}name} = constant
\end{array}
\]

\newcommand{\funo}{fun\sdash{}or\sdash{}node}

\[
\begin{array}{lcl}
  equation & \Coloneqq &
    \mathtt{automaton} \ state\sdash{}handler^+ \ \mathtt{end} \\
  & | & \mathtt{switch} \ expression \ \mathtt{of} \ switch\sdash{}handler^+ \\
  & | & \mathtt{present} \ present\sdash{}handler^+
    optional\sdash{}present\sdash{}handler \\
  & | & \mathtt{reset} \ block \ \mathrm{every} expression \\
  & | & pattern = expression; \\
  pattern & \Coloneqq & {\bf variable\sdash{}name} \\
  & | & \lp{}pattern,\dots,pattern\rp{} \\

  \\

  switch\sdash{}handler &
    \Coloneqq & | \ {\bf constructor\sdash{}name} \ block \\

  \\

  present\sdash{}handler & \Coloneqq &
    | \ expression \  block \\
  optional\sdash{}present\sdash{}handler & \Coloneqq & \epsilon \\
  & | & \mathtt{default} \ present\sdash{}handler \\

  \\
  state\sdash{}handler & \Coloneqq &
    \mathtt{state} \  {\bf state\sdash{}name} \ block
    \ until\sdash{}transitions? \  unless\sdash{}transitions? \\
  until\sdash{}transition & \Coloneqq & \mathtt{until} \ escapes^+ \\
  unless\sdash{}transition & \Coloneqq & \mathtt{unless} \ escapes^+ \\
  escape & \Coloneqq &
    expression \ \mathtt{then} \ {\bf constructor\sdash{}name} \\
    & | & expression \ \mathtt{continue} \ {\bf constructor\sdash{}name} \\

  \\

  block & \Coloneqq & variable\sdash{}declarations \ \mathtt{do} \ equation^* \\
  variable\sdash{}declarations & \Coloneqq & \epsilon \\
  & | & \mathtt{var} \ variable\sdash{}declaration^+ \\
  variable\sdash{}declaration & \Coloneqq & {\bf variable\sdash{}name} \ : type;
    \\

  \\

  \funo{} & \Coloneqq & \funo{}\sdash{}kind \ 
  {\bf \funo{}\sdash{}name}\lp{}variable\sdash{}declarations\rp{} \ \\
  & & \hspace{6.1cm}
    \mathtt{returns} \ \lp{}variable\sdash{}declarations\rp{} \\
  & & \mathtt{var} \ variable\sdash{}declarations \ \mathtt{let} \ equation^*
  \ \mathtt{tel} \\
  \funo{}\sdash{}kind & \Coloneqq & \mathtt{node} \p \mathtt{fun} \\

  \\

  const\sdash{}decl & \Coloneqq & \mathtt{const} \; ident : type = constant \\
  type\sdash{}decl & \Coloneqq & \mathtt{type} \ {\bf type\sdash{}name} \ = \ 
    type\sdash{}decl\sdash{}desc \\
  type\sdash{}decl\sdash{}desc & \Coloneqq & {\bf type\sdash{}name} \\
  & | & \lcb{} {\bf tag\sdash{}name}, \dots, {\bf tag\sdash{}name} \rcb{} \\
  & | & \lcb{} {\bf field\sdash{}name} : {\bf type\sdash{}name},\  \dots,\ 
    {\bf field\sdash{}name} : {\bf type\sdash{}name} \rcb{} \\
  program & \Coloneqq &
    const\sdash{}decl^* \  type\sdash{}decl^* \  \funo{}^*
\end{array}
\]

\end{document}
