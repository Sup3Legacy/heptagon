\documentclass[a4paper]{article}
%\usepackage[frenchb]{babel}
%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage{lmodern}
\usepackage{amsmath}
%\usepackage{tikz}
\usepackage{cite}
\usepackage{hyperref}
%\usepackage{fancyvrb}
%\usepackage{bm}
%\usepackage{pxfonts}
\usepackage{verbatim}
\usepackage{a4wide}
\usepackage{graphicx}

% Alter some LaTeX defaults for better treatment of figures:
% See p.105 of "TeX Unbound" for suggested values.
% See pp. 199-200 of Lamport's "LaTeX" book for details.
% General parameters, for ALL pages:
\renewcommand{\topfraction}{0.9}  % max fraction of floats at top
\renewcommand{\bottomfraction}{0.8} % max fraction of floats at bottom
% Parameters for TEXT pages (not float pages):
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{4}     % 2 may work better
\setcounter{dbltopnumber}{2}    % for 2-column pages
\renewcommand{\dbltopfraction}{0.9} % fit big float above 2-col. text
\renewcommand{\textfraction}{0.07}  % allow minimal text w. figs
% Parameters for FLOAT pages (not text pages):
\renewcommand{\floatpagefraction}{0.7}  % require fuller float pages
% N.B.: floatpagefraction MUST be less than topfraction !!
\renewcommand{\dblfloatpagefraction}{0.7} % require fuller float pages

% remember to use [htp] or [htpb] for placement


\newcommand{\FIXME}{\textcolor{red}{FIXME}}
%\newcommand{\TODO}[1]{(\textcolor{red}{TODO} #1)}
\newcommand{\TODO}[1]{}
\newcommand{\LANG}{Heptagon}

\newcommand{\bold}[1]{\textbf{#1}}
\newcommand{\p}[0]{\; \vert \;}
\newcommand{\rst}[1]{Rst(#1)}
\newcommand{\rstnd}[1]{RstNode(#1)}
% \newcommand{\rst}[1]{\llbracket #1 \rrbracket^{rst}}
\newcommand{\tvh}[2]{\llbracket #2 \rrbracket^{vhdl\ #1}}
\newcommand{\guardb}[1]{\llbracket #1 \rrbracket^{guard}}
\newcommand{\guard}[2]{\mbox{if } \guardb{#1} \mbox{ then } #2 \mbox{ else }
  \emptyset}
\newcommand{\mybox}[1]{\mbox{\tt{#1}}}
\newcommand{\bl}[0]{\hspace{0.45cm}}
\newcommand{\ind}[0]{\hspace{0.5cm}}
\newcommand{\Cons}[0]{\; \mathbf{::} \;}
\newcommand{\Coloneqq}[0]{::=}
\newcommand{\coloneqq}[0]{::=}
%% Syntaxe MiniLS

\newcommand{\Node}[4]{\mybox{node} \; f(#1) = #2 \; \mybox{with var} \
  #3 \; \mybox{in} \; #4}
\newcommand{\Op}[2]{\mybox{\bf{op}}(#1,\dots,#2)}
\newcommand{\Fby}[2]{#1 \, \mybox{fby}^{ck} \, #2}
\newcommand{\Pre}[1]{\mybox{pre}^{ck} \, #1}
\newcommand{\Every}[4]{#1^{ck}(#2,\dots,#3) \, \mybox{every} \, #4}
\newcommand{\App}[2]{#1^{ck}(#2)}
\newcommand{\If}[3]{\mybox{if} \; #1 \; \mybox{then} \; #2 \; \mybox{else} \; #3}
\newcommand{\When}[3]{#1 \; \mybox{when} \; #2(#3)}
\newcommand{\Merge}[5]{\mybox{merge} \; #1 \; (#2 \Rightarrow #3) \; \dots \; \
  (#4 \Rightarrow #5)}
\newcommand{\Base}[0]{\mybox{base}}
\newcommand{\On}[3]{#1 \mybox{ on } #2 (#3)}
\newcommand{\Map}[3]{\mathtt{map} \; #1 n (#2,\dots,#3)}
\newcommand{\Fold}[3]{\mathtt{fold} \; #1 n (#2,\dots,#3)}
\newcommand{\Mapfold}[3]{\mathtt{mapfold} \; #1 n (#2,\dots,#3)}

%% Syntaxe VHDL

\newcommand{\Component}[6]{\mybox{component} \; #1 \; \mybox{port} \; #2 \; \
  \mybox{with} \; \mybox{sig} \; #3 \; \mybox{and} \; \mybox{var} \; #4 \; \\
  \mybox{and} \; \mybox{subcomponents} \; #5 \; \mybox{in} \; #6}

\newcommand{\Assign}[2]{#1 \Leftarrow #2}
\newcommand{\Affect}[2]{#1 \coloneqq #2}
\newcommand{\Case}[5]{\mybox{case} \; #1 \; \mybox{of} \; (#2 \Rightarrow #3) \
  \dots (#4 \Rightarrow #5)}

\title{Traduction SCADE/Lustre vers VHDL~\thanks{Rapport d'\'etude dans
    le cadre du projet GENCOD}} 
\author{Adrien Guatto et Marc Pouzet
  \\ Universit\'e Pierre et Marie Curie \\
     \'Ecole normale sup\'erieure} 
\date{31 aout 2010}

\begin{document}

\maketitle

\section{Introduction}
Ce document pr\'esente une m\'ethode de compilation de programmes synchrones
\'ecrits dans un langage de type SCADE~6 vers VHDL. Il s'appuie sur la r\'ealisation
d'un prototype r\'ealis\'e au cours du projet et mis \`a la disposition des
autres partenaires de GENCOD. 

Le probl\`eme de la g\'en\'eration de code VHDL \`a partir de SCADE a \'et\'e envisag\'e sous
deux angles:
\begin{itemize}
\item
\end{itemize}

Le code VHDL est obtenu \`a partir du code Le A la diff\'erence de la solution propos\'ee par GeenSoft o\`u la g\'en\'eration de
code VHDL est obtenue \`a partir du code C g\'en\'er\'e par le compilateur KCG de
SCADEA6. Ce prototypune technique de traduction de programmes synchronespr\'esente une m\'ethode de traduction pr\'esente une approche 
On d\'etaille ici la traduction de \LANG{}, un langage synchrone combinant des
\'equations \`a flots de donn\'ees, dans l'esprit de Lustre, et des automates
hi\'erarchiques, tels qu'introduits par Lucid Synchrone et SCADE 6, vers le
langage de description de circuits VHDL. Cette traduction prend le parti de ne
pas passer par un langage imp\'eratif mais de directement utiliser la
repr\'esentation interne \`a flots de donn\'ees du compilateur.

Apr\`es avoir rappell\'e bri\`evement la forme des langages d'entr\'ee et de sortie, on
va expliciter la proc\'edure de traduction retenue.

\section{\LANG{}}

\LANG{} est un langage synchrone acad\'emique conceptuellement proche de SCADE,
mais un peu moins expressif : pas de signaux, peu de constructions riches
(\'emissions sur transitions, etc.). Par rapport aux it\'erations pr\'ec\'edente, il
dispose d\'esormais de tableaux de taille statique et des it\'erateurs associ\'es.

On va d\'ecrire rapidement quelques exemples illustrant les fonctionnalit\'es du
langage, avant de d\'etailler le processus de compilation et l'architecture du
compilateur.

\subsection{Quelques exemples}

\paragraph{Compteur d'\'ev\'enements simple}

\verbatiminput{simpcount.ept}

Le n≈ìud \textit{count} compte le nombre d'\'ev\`enements \textit{e} re\c{c}us depuis le
premier instant du programme.

\paragraph{Compteur multi-\'ev\'enements r\'einitialisable}

\begin{center}
  \verbatiminput{compteur.ept}
\end{center}

Ce programme implante un compteur d'\'ev\'enements qui comptabilise le nombre de
bool\'eens valant \texttt{true} sur son entr\'ee \textit{event}. On utilise les
it\'erateurs \texttt{map} et \texttt{fold} pour calculer le nombre d'\'ev\'enements
observ\'es dans l'instant ; le premier permet de traduire les bool\'eens en entiers,
et le second d'additioner ceux-ci. Notons \'egalement l'utilisation de la
construction de r\'einitialisation \texttt{reset}, actionn\'ee simplement lorsque
l'entr\'ee \textit{rst}\footnote{On suppose que le nom \textit{rst} est frais} est
vraie.

\paragraph{Allocateur de ressource}

\verbatiminput{alloc.ept}

Cet exemple pr\'esente un automate r\'ealisant l'allocation d'une ressource
quelconque \`a deux demandeurs, avec priorit\'e \textit{round-robin} (en cas de
demande simultann\'ee, le processus qui vera sa requ\^etre satisfaite sera celui
ayant obtenu la ressource il y a le plus longtemps).

\subsection{Architecture du compilateur}

On d\'ecrit bri\`evement l'architecture du compilateur : apr\`es des phases initiales
d'analyse lexicale, syntaxique et de typage, le programme \LANG{} est soumis aux
v\'erifications traditionnelles des langages synchrones (causalit\'e,
etc.). Ensuite, on le d\'epouille progressivement de ses constructions de haut
niveau par des r\'e\'ecritures successives, jusqu'\`a arriver \`a une forme simple qui
peut \^etre traduite simplement en MiniLS. Le code r\'esultant, apr\`es avoir \'et\'e
soumis \`a d'\'eventuelles optimisations, est mis dans une certaine forme dite
``normale'' et ordonnanc\'e avant d'\^etre finalement traduit en code
s\'equentiel. L'architecture du compilateur \LANG{} est pr\'esent\'e \`a la figure
\ref{fig:archi}.

% Le compilateur est structur\'e en plusieurs passes effectuant une combinaison
% d'analyses et de transformations, g\'en\'eralement dans le but d'obtenir un code
% imp\'eratif bas-niveau compilable avec les outils idoines. On d\'etaille bri\`evement
% ces diff\'erentes passes, d'abord dans le cas de la compilation traditionnelle
% (cercles verts du sch\'ema) vers un langage imp\'eratif, puis lorsque la cible est
% VHDL (cercles bleus). Les \'etapes quatre \`a sept sont d\'ecrites dans l'article
% \cite{lucy:lctes08a}.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=0.5]{archi}
  \caption{Architecture du compilateur \LANG{}}
  \label{fig:archi}
\end{figure}

Le passage au code s\'equentiel est court-circuit\'e lors d'une compilation vers
VHDL, qui traduit MiniLS directement vers celui-ci. Pour faciliter cette \'etape,
on pratiquera en amont trois transformations simplificatrices sur MiniLS.

\renewcommand{\labelenumi}{\Alph{enumi}}
\begin{enumerate}
\item Suppression de la r\'einitialisation logique.
\item Suppression des it\'erateurs sur tableaux via mise \`a plat.
\item Introduction d'une variable interm\'ediaire pour chaque argument d'un appel
  de noeud.
\item Traduction vers un sous ensemble de VHDL baptis\'e MiniVHDL.
\end{enumerate}

Le code MiniVHDL obtenu peut ensuite \^etre trait\'e par les outil d\'edi\'es.

\section{De \LANG{} \`a VHDL}

\subsubsection{Syntaxes}

\TODO{Donner la forme originale sans reset telle qu'avant normalisation ?}

\paragraph{MiniLS}
\label{sec:syn:mls}

\begin{figure}[h]
  \centering
  \begin{eqnarray*}
    td & \Coloneqq & \mybox{type } bt = C + \dots + C \\
    d & \Coloneqq & \Node{p}{p}{p}{D} \\
    p & \Coloneqq & x : bt; \dots; x : bt \\
    D & \Coloneqq & pat = e; \dots; pat = e \\
    pat & \Coloneqq & x \p (pat,\dots,pat) \\
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \Fby{v}{e} \p \Pre{e} \\
    & \p & \Every{f}{e}{e}{x} \p \When{e}{C}{x} \\
    & \p & \Merge{x}{C}{e}{C}{e} \\
    & \p & \Map{f}{e_1}{e_n} \\
    & \p & \Fold{f}{e_1}{e_n} \\
    & \p & \Mapfold{f}{e_1}{e_n} \\
    v & \Coloneqq & i \p C \\
    ck & \Coloneqq & \Base \p \On{ck}{C}{x}
  \end{eqnarray*}
  \caption{MiniLS}
  \label{fig:mls}
\end{figure}

MiniLS est \'equivalent au langage synchrone \`a flots de donn\'ees bien connu qu'est
Lustre \cite{lustre}, auquel on adjoint une construction de r\'einitialisation
modulaire d'un noeud\footnote{$\Every{f}{e_1}{e_n}{z}$ appelle le noeud $f$ avec
  les arguments $e_1,\dots,e_n$, et r\'einitialise la m\'emoire de celui-ci lorsque
  $z$ est vraie.}.

Les programmes MiniLS sont pr\'esents dans le compilateur sous trois formes
distinctes ; la premi\`ere est donn\'ee par souci de coh\'erence et ne nous int\'eresse
pas directement, les pr\'ec\'edentes passes du compilateur nous fournissant
directement la deuxi\`eme. Ce processus de compilation est d\'ecrit en d\'etails dans
l'article \cite{lctes08a}.

\begin{itemize}
\item Forme originale \ref{fig:mls} telle qu'obtenue \`a partir du code \LANG{}
  original.
\item Forme normale \ref{fig:mlsn}.
\item Forme finale \ref{fig:mlsns}, normalis\'ee, sans r\'einitialisations ($every$)
  ni it\'erateurs, et o\`u tous les param\`etres effectifs sont des noms
  d'identifiants.
\end{itemize}

On va d\'ecrire les constructions du langage :

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \When{e}{C}{x} \\
    ce & \Coloneqq & e \p \Merge{x}{C}{ce}{C}{ce} \\
    eq & \Coloneqq & x = ce \p x = \Fby{v}{e} \p x = \Pre{e} \\
    & \p & (x,\dots,x) = \Every{f}{e}{e}{x} \\
    & \p & (x,\dots,x) = \App{f}{e,\dots,e} \\
    & \p & \Map{f}{e_1}{e_n} \\
    & \p & \Fold{f}{e_1}{e_n} \\
    & \p & \Mapfold{f}{e_1}{e_n}
  \end{eqnarray*}
  \caption{MiniLS normalis\'e}
  \label{fig:mlsn}
\end{figure}

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \When{e}{C}{x} \\
    ce & \Coloneqq & e \p \Merge{x}{C}{ce}{C}{ce} \\
    eq & \Coloneqq & x = \Pre{e} \\
    & \p & (x,\dots,x) = \App{f}{x,\dots,x}
  \end{eqnarray*}
  \caption{MiniLS simplifi\'e (et normalis\'e)}
  \label{fig:mlsns}
\end{figure}

\paragraph{MiniVHDL}

MiniVHDL \ref{fig:mvhdl} est un fragment tr\`es restreint de VHDL, suffisant pour
d\'ecrire l'essence de notre processus de traduction. Un composant MiniVHDL
$\Component{f}{P}{sigs}{lvars}{ports}{I}$ correspondra concr\`etement \`a un
composant VHDL form\'e des instantiations $ports$, signaux internes $sigs$ et d'un
processus avec les variables locales $lvars$ et de corps $I$.

Notons que les param\`etres effectifs des instantiations de composants sont des
noms de signaux ; cela justifie la forme simplifi\'ee MiniLS d\'ecrite au paragraphe
pr\'ec\'edent.

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    component & \Coloneqq & \mybox{component} \; f \; \mybox{port} \; sm;\dots;\
    sm \; \mybox{with} \, \mybox{sig} \; d; \dots; d \; \\
    & & \mybox{and} \, \mybox{var} \; d; \dots; d \; \mybox{and} \
    \mybox{subcomponents} \; p; \dots; p \; \mybox{in} \; I \\
    sm & \Coloneqq & x : mode \ ty \\
    sd & \Coloneqq & x : mode \ ty \coloneqq e \\
    mode & \Coloneqq & \mybox{in} \p \mybox{out} \\
    d & \Coloneqq & x : ty \\
    p & \Coloneqq & \mybox{port map } x (bd;\dots;bd) \\
    bd & \Coloneqq & x \Rightarrow x \\
    I & \coloneqq & i; \dots; i \\
    i & \Coloneqq & \Assign{x}{e} \p \Affect{x}{e} \p \Case{e}{v}{I}{v}{I} \\
    e & \Coloneqq & id \; \vert \; v \; \vert \; \Op{e}{e} \\
    v & \Coloneqq & i \; \vert \; ' bitp ' \\
    bitp & \Coloneqq & bit \p bit \  bitp \\
    bit & \Coloneqq & \mathbf{0} \p \mathbf{1} \\
    bt & \Coloneqq & \mybox{natural} \p \mybox{std\_logic} \p \mybox{bit}
    \p \dots
  \end{eqnarray*}
  \caption{MiniVHDL}
  \label{fig:mvhdl}
\end{figure}

% On y ajoute comme raccourci syntaxique l'instruction suivante : $$\mybox{if } e
% \mybox{ then } I \mybox{ else } J \equiv \mybox{case } e \mybox{ of } ('1'
% \Rightarrow I) ('0' \Rightarrow J)$$

\subsubsection{Simplification de MiniLS normalis\'e}

Nous effectuons donc trois passes pour simplifier le code MiniLS.

\paragraph{\'Elimination de la r\'einitialisation logique}

Certaines constructions de MiniLS proposent au programmeur une forme de
r\'einitialisation modulaire : les \'equations de la forme $\Fby{v}{e}$ d'un noeud
$f$ instanci\'e par la construction $\Every{f}{e_1}{e_n}{z}$ doivent-\^etre
r\'einitialis\'ees d\`es lors que $z$ est vrai.

La premi\`ere passe de simplification, qui s'ex\'ecute sur le code MiniLS obtenu \`a
la troisi\`eme \'etape du processus d\'ecrit plus haut, permet d'\'eliminer ces
constructions $every$ dans le but de compiler plus uniform\'ement vers VHDL,
autrement dit sans n\'ecessiter un traitement ad-hoc de la r\'einitialisation.

L'id\'ee est d'ajouter \`a chaque noeud un argument suppl\'ementaire nomm\'e
\textit{rst} correspondant \`a un appel n\'ecessitant une r\'einitialisation de la
m\'emoire. La passe se charge de modifier les appels de noeuds pour synth\'etiser
l'expression correcte, en particulier dans le cas d'une \'equation de type $(x_1,
\dots, x_n) = \Every{f}{e}{e}{x}$ o\`u $x$ doit \^etre capable de r\'einitialiser
$f$. Les m\'emoires r\'einitialisables $\Fby{v}{e}$ doivent bien-entendu \^etre
r\'einitialis\'ees lorsque l'argument \texttt{rst} est vrai ; pour cela, il suffit
de remplacer ces derni\`eres par $\If{rst}{v}{\newline \Pre{e}}$.

Les fonctions suivantes effectuent ces deux t\^aches : $RstE$ traite une
expression MiniLS, et $RstNode$ ajoute l'argument \texttt{rst} \`a un noeud et
transforme ses \'equations.

\newcommand{\re}[1]{RstE(#1)}
\newcommand{\rstn}[1]{RstNode(#1)}

\[
\begin{array}{lcl}
  \re{\Op{e_1}{e_n}} & = & \Op{\re{e_1}}{\re{e_n}} \\
  \re{\Fby{v}{e}} & = & \If{rst}{v}{\Fby{v}{\re{e}}} \\
  \re{\Pre{e}} & = & \Pre{\re{e}} \\
  \re{\Every{f}{e_1}{e_n}{x}} & = & \App{f}{\mathtt{rst} \; \mathbf{or} \;
    x, \re{e_1} \dots, \re{e_n}} \\
  \re{\App{f}{e_1,\dots,e_n}} & = &
  \App{f}{\mathtt{rst},\re{e_1},\dots,\re{e_n}} \\
  \re{\If{e_1}{e_2}{e_3}} & = & \If{\re{e_1}}{\re{e_2}\\ & & \hspace{1.7cm}}
  {\re{e_3}} \\
  \re{\When{e}{C}{x}} & = & \When{\re{e}}{C}{x} \\
  \re{\Merge{e}{C_1}{e_1}{C_n}{e_n}} & = &
  \mybox{merge} \; \re{e} \; (C_1 \Rightarrow \re{e_1}) \\
  & & \hspace{2.2cm} \dots \\
  & & \hspace{2.2cm} (C_n \Rightarrow \re{e_n})
\end{array}
\]

\[
\begin{array}{ll}
  RstEqs(pat_1 = e_1;\dots;pat_n = e_n) & = \\
  \ind pat_1 = \re{e_1};\dots;pat_n = \re{e_n} \\
  \rstn{\Node{f}{x_1,\dots,x_n}{y_1,\dots,y_n}{eqs}} & = \\
  \ind \Node{f}{rst,x_1,\dots,x_n}{y_1,\dots,y_n}{ResetEqs(eqs)}
\end{array}
\]

\paragraph{Suppression des it\'erateurs}

La version actuelle du compilateur et de son g\'en\'erateur de code VHDL supporte
les tableaux de dimension arbitraire \footnote{En pratique, les outils de
  synth\`ese de circuits \`a partir de code VHDL imposent une dimension maximale.}
et constructions associ\'ees ; il nous faut donc compiler les it\'erateurs
\texttt{map}, \texttt{fold} et \texttt{mapfold} vers VHDL.

Par souci de simplicit\'e et uniformit\'e, nous avons fait le choix de les \'eliminer
par \textit{inlining} lors d'une transformation source-\`a-source sur MiniLS. On
ne d\'etaillera pas cette op\'eration qui consiste simplement \`a remplacer les
it\'erateurs par plusieurs \'equations. L'\'equation $x = \Map{f}{t_1}{t_m}$ lorsque
les tableaux $t_1, \dots, t_m$ sont de taille $n$ sera ainsi remplac\'ee par $n +
1$ \'equations dont les $n$ premi\`eres effectuent l'application de $f$ pour chaque
indice et la derni\`ere affecte \`a $x$ le tableau en r\'esultant. On applique des
transformations similaires aux op\'erateurs \texttt{fold} et \texttt{mapfold}.

Le programme suivant pr\'esente un exemple effectuant un ET logique sur tous les
\'el\'ements d'un tableau via l'it\'erateur \texttt{fold}.

\verbatiminput{fold_orig.ept}

Son pendant avec it\'erateur mis \`a plat se contente de passer l'accumulateur
d'\'el\'ement en \'el\'ement.

\verbatiminput{fold_il.ept}

\paragraph{Simplification des appels}

Comme nous le verrons plus bas, les appels de n≈ìuds seront compil\'es en
instantiations de composants ; or, les arguments d'une construction VHDL $port
\; map$ sont forc\'ement des identifiants. Autant se simplifier la t\^ache en amont
: on va donc transformer tout appel de noeud en introduisant une variable
interm\'ediaire pour chaque argument.

\newcommand{\simpl}[2]{Simpl(#1,#2)}
\newcommand{\simplnd}[1]{SimplNode(#1)}

\[
\begin{array}{ll}
  \simpl{x = ce}{eqs} & = \\
  \ind (x = ce) \Cons eqs \\
  \simpl{x = \Pre{e}}{eqs} & = \\
  \ind (x = \Pre{e}) \Cons eqs \\

  \simpl{(x_1,\dots,x_n) = \App{f}{e_1,\dots,e_n}}{eqs} & = \\
  \ind (y_1 = e_1) \Cons \dots \Cons (y_n = e_n)
  \Cons ((x_1,\dots,x_n) = \App{f}{rst,y_1,\dots,y_n}) \Cons eqs \\
  \ind \mbox{o\`u } y_1,\dots,y_n \mbox{ sont des noms de variables frais}
\end{array}
\]

\[
\begin{array}{ll}
  \simplnd{\Node{x_1,\dots,x_n}{y_1,\dots,y_n}{p}{D}} & = \\
  \ind \mathtt{node} f(x_1,\dots,x_n) = y_1, \dots, y_n \; \\
  \ind \mathtt{with} \  \mathtt{var} \; p' \; \mathtt{in} \; fold\_right \;Simpl
  \; D \; [] \\
  \ind \mbox{en supposant que que } p' \mbox{ correspond} \\
  \ind \mbox{aux variables d\'efinies par les nouvelles \'equations.}
\end{array}
\]

Ces simplifications effectu\'ees, on va s'atteler \`a la traduction de MiniLS vers
MiniVHDL.

\subsubsection{MiniLS simplif\'e vers MiniVHDL}

Les id\'ees g\'en\'erales de la traduction de MiniLS simplifi\'e vers MiniVHDL sont les
suivantes :

\begin{itemize}
\item Chaque noeud MiniLS correspondra \`a un composant (Mini)VHDL.
\item Chaque \'equation \`a m\'emoire (i.e. contenant $fby$ ou $pre$) va correspondre
  \`a un signal, chaque \'equation combinatoire \`a une variable locale.
\item La r\'einitialisation logique est g\'er\'ee en amont comme expliqu\'ee ci-dessus,
  elle est donc implicitement asynchrone (ind\'ependante des fronts montants de
  l'horloge).
\item Les partenaires ont exprim\'e le d\'esir de pouvoir r\'einitialiser physiquement
  toute la m\'emoire lors du bascument d'un signal pr\'ecis nomm\'e
  \textit{hwrst}\footnote{Tout comme \textit{rst}, \textit{hwrst} est frais.} :
  on ajoute donc ce signal suppl\'ementaire invisible dans le code MiniLS et on
  g\'en\`ere le code de r\'einitialisation correspondant lors du traitement du $fby$.
\item Pour respecter la s\'emantique \`a $\Delta$-cycles de VHDL, il importe de
  faire \'evoluer la m\'emoire par un pas du calcul uniquement sur front montant de
  l'horloge.
\item En suivant le mod\`ele synchrone, les valeurs calcul\'ees par le circuit \`a
  d'autres moments que le front montant n'ont pas de sens bien d\'efini ; on les
  ignorera donc.
\item Chaque appel de noeud correspondra \`a une instantiation. Comme sp\'ecifi\'e
  plus haut, les param\`etres effectifs d'un signal VHDL sont obligatoirement des
  signaux auxquels il faudra assigner la valeur correcte.
\end{itemize}

\paragraph{Traduction des types}

Les d\'eclarations de types de donn\'ees ont \'et\'e laiss\'ees implicites aussi bien dans
la syntaxe de MiniLS que de MiniVHDL ; les possibilit\'es \'etant exactement les
m\^emes (\'enum\'erations et enregistrements), on choisit de ne pas s'attarder sur
leur traduction qui reste une traduction mot-\`a-mot d'une syntaxe concr\`ete \`a
l'autre.

\paragraph{Traduction des constantes et fonction auxiliaires sur les horloges}

La fonction $TradConst$ traduit une constante MiniLS en constante MiniVHDL.

\newcommand{\TradC}[1]{TradConst(#1)}

\[
\begin{array}{lcl}
  \TradC{i} & = & i \\
  \TradC{true} & = & '1' \\
  \TradC{false} & = & '0' \\
  \TradC{C} & = & C
\end{array}
\]

La fonction auxiliaire $GuardClock$ permet de traduire une horloge MiniLS en
expression MiniVHDL de type bool\'een. Elle sera utilis\'ee pour contr\^oler la mise \`a
jour des registres, s'assurant que cette derni\`ere n'est effectu\'ee qu'aux
instants o\`u l'horloge est effective.

\newcommand{\GEC}[1]{GuardClock(#1)}

\[
\begin{array}{lcl}
  \GEC{\Base} & = & rising\_edge(clk) \\
  \GEC{\On{ck}{C}{x}} & = & x = \TradC{C} \; \mathtt{and} \; \GEC{ck}
\end{array}
\]

Tout comme les mises \`a jour des m\'emoires, les appels \`a d'autres noeuds sont
dirig\'es par les horloges qui en donnent la cadence. Il nous faudra donc une
fonction voisine de $GuardClock$ pour calculer l'expression MiniVHDL
correspondant \`a l'horloge utilis\'ee dans l'appel d'un noeud.

\newcommand{\EC}[1]{ExpClock(#1)}

\[
\begin{array}{lcl}
  \EC{\Base} & = & clk \\
  \EC{\On{ck}{C}{x}} & = & x = \TradC{C} \; \mathtt{and} \; \EC{ck}
\end{array}
\]

\paragraph{Traduction des expressions et \'equations}

La fonction $TradExp$ traduit les expressions simples MiniLS normalis\'es et
simplifi\'e en expressions MiniVHDL.

\newcommand{\TradE}[1]{TradExp(#1)}

\[
\begin{array}{lcl}
  \TradE{v} & = & \TradC{v} \\
  \TradE{x} & = & x \\
  \TradE{\Op{e_1}{e_n}} & = & \Op{\TradE{e_1}}{\TradE{e_n}} \\
  \TradE{\When{e}{C}{x}} & = & \TradE{e}
\end{array}
\]

La fonction $TradCExp$ traduit les expressions de contr\^ole form\'ees d'expressions
simples ou de \texttt{merge} imbriqu\'es en instructions MiniVHDL.

\newcommand{\TradCE}[2]{TradCExp(#1, #2)}

\[
\begin{array}{ll}
  \TradCE{x}{\Merge{y}{C_1}{ce_1}{C_n}{ce_n}} & = \\
  \ind \mathtt{case} \; y \; \mathtt{of} \;
  (\TradC{C_1} \Rightarrow \TradCE{x}{ce_1}) \\
  \hspace{2.1cm} \dots \\
  \hspace{2.1cm} (\TradC{C_n} \Rightarrow \TradCE{x}{ce_n}) \\
  \TradCE{x}{e} & = \\
  \ind \Affect{x}{\TradE{e}}
\end{array}
\]

Enfin, la fonction $TradEq$ permet de passer des \'equations aux instructions
MiniVHDL. Elle prend un argument suppl\'ementaire permettant de compter le nombre
d'appels de noeuds afin de g\'en\'erer des arguments suppl\'ementaires, et on se donne
une fonction suppl\'ementaire $MakeArg(x,i)$ qui g\'en\`ere un nom de variable frais \`a
partir du nom de variable $x$ et de l'entier $i$.

La traduction des \'equations appelant un noeud n\'ecessite des explications
concernant la fa\c{c}on de compiler les appels d'un noeud MiniLS qui seront donn\'ees
\`a la section suivante.

\newcommand{\TradEq}[2]{TradEq(#1,#2)}
\newcommand{\MA}[2]{MakeArg(#1,#2)}

\[
\begin{array}{lcl}
  \TradEq{x = ce}{i} & = & \TradCE{x}{ce}, i \\

  \TradEq{x = \Pre{e}}{i} & = & \mathtt{if} \; \GEC{ck} \; \mathtt{then} \\
  & & \ind \Assign{x}{\TradE{e}} \\
  & & \mathtt{end} \; \mathtt{if}, i \\

  \TradEq{x = \Fby{y}{e}}{i} & = & \mathtt{if} \; \mathbf{hwrst}
  \; \mathtt{then} \\
  & & \ind \Assign{x}{y} \\
  & & \mathtt{elsif} \; \GEC{ck} \; \mathtt{then} \\
  & & \ind \Assign{x}{\TradE{e}} \\
  & & \mathtt{end} \; \mathtt{if}, i \\


  \TradEq{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}}{n} & = &
  \Assign{\MA{"ck"}{i}}{\EC{ck}} \\
  & & \Assign{\MA{y_1}{i}}{y_1} \\
  & & \dots \\
  & & \Assign{\MA{y_n}{i}}{y_n}, i + 1 \\
\end{array}
\]

Pr\'ecisons que par construction, l'interface d'un composant est toujours de la
forme $(clk, in_1, \dots,in_n, out_1,\dots,out_n)$.

\paragraph{Gestion des tableaux}

Hormis le cas des it\'erateurs trait\'es pr\'ec\'edemment, la gestion des tableaux
n'appelle pas de commentaire particulier, \`a l'exception de l'anecdotique mais
g\^enante n\'ecessit\'e de d\'eclarer \`a l'avance les types tableaux (bornes exclues) en
VHDL. Deux solutions sont envisageables :

\begin{itemize}
\item Calculer la dimension maximale des tableaux rencontr\'es dans le programme,
  et utiliser cette information pour pr\'e-d\'eclarer les tableaux VHDL idoines.
\item D\'eclarer quoi qu'il advienne les types de tableaux utiles et refuser les
  programmes comprenant des dimensions sup\'erieures \`a une limite fix\'ee \`a l'avance
  .
\end{itemize}

Le compilateur emploie pour l'instant la premi\`ere m\'ethode, mais la seconde ne
nous semble pas d\'erangeante pour des raisons pragmatiques\footnote{Notons que
  notre version de l'outil Xilinx ISE refuse par exemple tout tableau de
  dimension sup\'erieure \`a trois.}.

\paragraph{Compilation modulaire et appels de noeuds}

MiniVHDL offre une forme de modularit\'e bas\'ee sur une hi\'erarchie de
composants. Chacun de ces derniers sp\'ecifie une liste de composants fils dont
les ports (au sens de la figure \ref{fig:mvhdl}) sont instanci\'es avec des
signaux. Nous prenons donc soin d'utiliser des signaux comme r\'esultats mais
aussi arguments ; par souci de simplicit\'e, on introduit des signaux locaux pour
chaque argument, signaux qui seront affect\'es lors de la traduction de l'\'equation
correspondant \`a l'appel de noeud original.

La fonction $GatherPortMaps(D, i)$ rassemble cette liste de sous-noeuds \`a partir
des appels de noeud pr\'esents dans le paquet d'\'equations $D$ et cr\'e\'e les
instantiations de composants correspondantes. L'entier $i$ nous servira \`a
distinguer les appels de noeuds et de cr\'eer de nouveaux noms de signaux frais
gr\^ace \`a la fonction $MakeArg$ d\'ecrite plus haut. On se donne \'egalement une
fonction $GetArgName(f,n)$ qui renvoie le nom du $n$-\`eme argument du noeud de
nom $f$.

\newcommand{\GPM}[2]{GatherPortMaps(#1,#2)}
\newcommand{\GAN}[2]{GetArgName(#1,#2)}

\[
\begin{array}{lcl}
  \GPM{[]}{i} & = & [] \\
  \GPM{((x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}) \Cons eqs}{i} & = &
  \\
  \ind \mybox{port map} \; f ( clk \Rightarrow \MA{"clk"}{i} \\
  \ind \ind \ind \ind \hspace{0.4cm} \GAN{f}{1} \Rightarrow \MA{y_1}{i} \\
  \ind \ind \ind \ind \hspace{0.4cm} \dots \\
  \ind \ind \ind \ind \hspace{0.4cm} \GAN{f}{n} \Rightarrow \MA{y_n}{i}) \\
  \ind \Cons \GPM{eqs}{i + 1}
\end{array}
\]

On d\'efinit ensuite les fonctions auxiliaires $NeedVar$, $Vars$, $ParamSigs$ et
$SignalOfVarDec$ respectivement charg\'ees de d\'eterminer si une \'equation introduit
des d\'eclarations de variables locales ou non, de calculer la liste des variables
d\'efinies par une \'equation, de calculer les signaux \`a passer en arguments aux
appels de noeuds pr\'esents dans un paquet d'\'equations et enfin de traduire
simplement une d\'eclaration de variable MiniLS en d\'eclaration de signal MiniVHDL
avec mode d'utilisation (entr\'ee ou sortie).

\newcommand{\NV}[1]{NeedVar(#1)}
\newcommand{\V}[1]{Vars(#1)}
\newcommand{\PS}[2]{ParamSigs(#1,#2)}
\newcommand{\SoVD}[3]{SignalOfVarDec(#1 : #2, #3)}

\[
\begin{array}{lcl}
  \NV{x = \Fby{v}{e}} & = & false \\
  \NV{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}} & = & false \\
  \NV{x = ce} & = & true
\end{array}
\]

\[
\begin{array}{lcl}
  \V{x = \Fby{v}{e}} & = & [x] \\
  \V{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}} & = & x_1 \Cons \dots \Cons x_n \\
  \V{x = ce} & = & [x]
\end{array}
\]

\[
\begin{array}{ll}
  \PS{x = \Fby{v}{e} \Cons eqs}{i} & = \\
  \ind \PS{eqs}{i} \\
  \PS{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n} \Cons eqs}{i} & = \\
  \ind \MA{"clk"}{i} \Cons \MA{y_1}{i} \Cons \dots \Cons \MA{y_n}{i} \\
  \ind \mathtt{::} \; \PS{eqs}{i + 1}
  \\
  \PS{x = ce \Cons eqs}{i} & = \\
  \ind \PS{eqs}{i}
\end{array}
\]

\[
\begin{array}[lcl]{lcl}
  \SoVD{x}{bt}{mode} & = & \mybox{signal} \; x : mode \; TransBaseType(bt)
\end{array}
\]

\paragraph{Traduction des noeuds}

Enfin, $TradNode$ se charge de traduire un noeud en composant MiniVHDL, en
cr\'eant un signal local pour chaque \'equation retard\'ee et argument d'appel de
noeud, une variable pour chaque \'equation combinatoire, et la liste de
sous-composants requise.

\begin{align*}
  & TradNode(\mybox{node } f(in) = out \mybox{ with var } p \mybox{ in } D) = \\
  & \bl \mbox{soit } port = \\
  & \bl \bl clk : \mybox{in std\_logic}; \\
  & \bl \bl \{ SignalOfVarDec(x : bt, \mybox{in}) \p (x : bt) \in in \}; \\
  & \bl \bl \{ SignalOfVarDec(x : bt, \mybox{out}) \p (x : bt) \in out \}, \\
  & \bl \mbox{ soit } signals = \{ \V{eq} \p eq \in D, \neg \NV{eq} \}
  \mybox{,} \\
  & \bl \mbox{ soit } sig\_args = \PS{D}{1} \mybox{,} \\
  & \bl \mbox{ soit } variables = \{ \V{eq} \p eq \in D, \NV{eq} \} \mybox{,} \\
  & \bl \mbox{ soit } ports = \GPM{D}{1} \mybox{,} \\
  & \bl \mbox{ soit } body = fold\_right TradEq D ([], 1) \mbox{ dans} \\
  & \mybox{component } f \mybox{ port } port \mybox{ with sig } signals \cup
  sig\_args \\
  & \mybox{and var } variables \mybox{ and subcomponents } ports \mybox{ in }
  body
\end{align*}

\section{Discussion}

\section{Conclusion}

On a traduit \LANG{} vers VHDL en profitant des forces du mod\`ele synchrone : sa
s\'emantique est bien adapt\'ee \`a une description sous forme de circuits. Le
processus de traduction reste simple et compr\'ehensible gr\^ace aux garanties
offertes par le synchrone : nul besoin d'\'ecrire plusieurs fois dans le m\^eme
\'el\'ement m\'emorisant par cycle.

\tableofcontents


\appendix

\section{Exemples de code g\'en\'er\'e}

On pr\'esente ici quelques codes g\'en\'er\'es par notre prototype. En l'\'etat actuel de
ce dernier, beaucoup de variables interm\'ediaires sont g\'en\'er\'ees ; une passe
d'optimisation puissante est en d\'eveloppement.

On liste successivement le code MiniLS obtenu \`a partir de \LANG{}, puis le code
MiniLS normalis\'e et ordonnanc\'e, et enfin le code VHDL.

\subsection{Compteur}

\paragraph{MiniLS initial}

\small
\verbatiminput{compteur2_init.mls}
\normalsize

\paragraph{MiniLS normalis\'e, ordonnanc\'e et simplifi\'e}

Notons que le noeud \textit{compteur} est ici instanci\'e avec son param\`etre
\textit{n} \'egal \`a 4, ceci afin de pouvoir d\'eplier les it\'erateurs.

\small
\verbatiminput{compteur2_sched.mls}
\normalsize

\paragraph{VHDL}

\small
\verbatiminput{compteur2_vhdl.vhd}
\normalsize

\subsection{Allocateur de ressource}

\paragraph{MiniLS initial}

\small
\verbatiminput{al2_init.mls}
\normalsize

\paragraph{MiniLS normalis\'e, ordonnanc\'e et simplifi\'e}

\small
\verbatiminput{al2_sched.mls}
\normalsize

\paragraph{VHDL}

\small
\verbatiminput{al2_vhdl.vhd}
\normalsize

\section{Utilisation du compilateur}

Nous supposerons dans ce manuel que l'archive du compilateur a \'et\'e d\'ecompress\'ee
dans le r\'epertoire \verb/$HEPTDIR/. Cette archive contient le pr\'esent rapport,
un r\'epertoire \texttt{exs/} avec une batterie d'exemples \LANG{} compil\'es vers
VHDL, et un binaire en code-octet pour la machine abstraite OCaml. Ce dernier
peut-\^etre ex\'ecut\'e via \texttt{ocamlrun heptc}, ou bien directement lorsque votre
\texttt{ocamlrun} est pr\'esent dans \texttt{/usr/bin/}. Nous supposerons par la
suite que c'est le cas et que votre variable d'environnement \verb/$PATH/
contient \verb/$HEPTDIR/bin/.

Pour utiliser le compilateur, il faut tout d'abord renseigner la variable
d'environnement \verb/$HEPTLIB/ sp\'ecifiant au compilateur o\`u trouver la
biblioth\`eque standard.

\begin{verbatim}
$ export HEPTLIB=$HEPTDIR/lib
\end{verbatim}

Vous pouvez ensuite v\'erifier que le compilateur est disponible et fonctionnel
via la commande suivante :

\begin{verbatim}
$ heptc -version
The Heptagon compiler, version 0.4 (wed. aug. 18 11:17:42 CET 2010)
Standard library in [...]
\end{verbatim}

Pour compiler un fichier \LANG{}, le compilateur doit \^etre invoqu\'e avec l'option
\verb/-target/. Les arguments possibles pour cette option sont :

\begin{itemize}
\item \verb/vhdl/ : g\'en\`ere du code VHDL.
\item \verb/mls/ : g\'en\`ere le code \`a flots de donn\'ees MiniLS interm\'ediaire.
\item \verb/obc/ : g\'en\`ere un code imp\'eratif simple dans le langage id\'ealis\'e Obc.
\item \verb/c/ : g\'en\`ere du code C.
\end{itemize}

Les cibles VHDL et C invoqu\'ees sur un fichier \verb/source.ept/ produisent
respectivement un dossier \verb/source_vhdl/ et \verb/source_c/ qui contiennent
les fichiers sources g\'en\'er\'es. Par exemple :

\begin{verbatim}
$ cat source.ept
node main() returns (o : int)
let
  o = 0 fby (o + 1);
tel
$ heptc -target vhdl source.ept
$ ls source_vhdl
main.vhd  types.vhd
\end{verbatim}

L'option \verb/-s noeud/ permet de g\'en\`erer le code n\'ecessaire \`a un ex\'ecutable
autonome \`a partir d'un fichier source \LANG{}, c'est \`a dire un
\textit{test-bench} dans le cas de VHDL et une fonction \verb/main()/ en ce qui
concerne C. Voici un exemple d'utilisation de la sortie C :

\begin{verbatim}
$ cat source.ept
node noeud() returns (o : int)
let
  o = 0 fby (o + 1);
tel

node main() returns (o : int)
let
  o = noeud() + 1;
tel
$ heptc -target c -s main source.ept
$ ls source_c
_main.c  _main.h  source.c  source.h  source_types.c  source_types.h
$ cc -Isource_c source_c/*.c -o source
$ ./source 5 # Option indiquant \`a l'ex\'ecutable g\'en\'er\'e de s'arr\^eter apr\`es 5 pas
=> 1
=> 2
=> 3
=> 4
=> 5
\end{verbatim}

\bibliography{biblio}
\bibliographystyle{plain}

\end{document}
