\documentclass[a4paper]{article}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage{lmodern}
\usepackage{amsmath}
%\usepackage{tikz}
\usepackage{cite}
\usepackage{hyperref}
%\usepackage{fancyvrb}
%\usepackage{bm}
%\usepackage{pxfonts}
\usepackage{verbatim}
\usepackage{a4wide}
\usepackage{graphicx}

% Alter some LaTeX defaults for better treatment of figures:
% See p.105 of "TeX Unbound" for suggested values.
% See pp. 199-200 of Lamport's "LaTeX" book for details.
% General parameters, for ALL pages:
\renewcommand{\topfraction}{0.9}  % max fraction of floats at top
\renewcommand{\bottomfraction}{0.8} % max fraction of floats at bottom
% Parameters for TEXT pages (not float pages):
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{4}     % 2 may work better
\setcounter{dbltopnumber}{2}    % for 2-column pages
\renewcommand{\dbltopfraction}{0.9} % fit big float above 2-col. text
\renewcommand{\textfraction}{0.07}  % allow minimal text w. figs
% Parameters for FLOAT pages (not text pages):
\renewcommand{\floatpagefraction}{0.7}  % require fuller float pages
% N.B.: floatpagefraction MUST be less than topfraction !!
\renewcommand{\dblfloatpagefraction}{0.7} % require fuller float pages

% remember to use [htp] or [htpb] for placement


\newcommand{\FIXME}{\textcolor{red}{FIXME}}
%\newcommand{\TODO}[1]{(\textcolor{red}{TODO} #1)}
\newcommand{\TODO}[1]{}
\newcommand{\LANG}{Heptagon}

\newcommand{\bold}[1]{\textbf{#1}}
\newcommand{\p}[0]{\; \vert \;}
\newcommand{\rst}[1]{Rst(#1)}
\newcommand{\rstnd}[1]{RstNode(#1)}
% \newcommand{\rst}[1]{\llbracket #1 \rrbracket^{rst}}
\newcommand{\tvh}[2]{\llbracket #2 \rrbracket^{vhdl\ #1}}
\newcommand{\guardb}[1]{\llbracket #1 \rrbracket^{guard}}
\newcommand{\guard}[2]{\mbox{if } \guardb{#1} \mbox{ then } #2 \mbox{ else }
  \emptyset}
\newcommand{\mybox}[1]{\mbox{\tt{#1}}}
\newcommand{\bl}[0]{\hspace{0.45cm}}
\newcommand{\ind}[0]{\hspace{0.5cm}}
\newcommand{\Cons}[0]{\; \mathbf{::} \;}
\newcommand{\Coloneqq}[0]{::=}
\newcommand{\coloneqq}[0]{::=}
%% Syntaxe MiniLS

\newcommand{\Node}[4]{\mybox{node} \; f(#1) = #2 \; \mybox{with var} \
  #3 \; \mybox{in} \; #4}
\newcommand{\Op}[2]{\mybox{\bf{op}}(#1,\dots,#2)}
\newcommand{\Fby}[2]{#1 \, \mybox{fby}^{ck} \, #2}
\newcommand{\Pre}[1]{\mybox{pre}^{ck} \, #1}
\newcommand{\Every}[4]{#1^{ck}(#2,\dots,#3) \, \mybox{every} \, #4}
\newcommand{\App}[2]{#1^{ck}(#2)}
\newcommand{\If}[3]{\mybox{if} \; #1 \; \mybox{then} \; #2 \; \mybox{else} \; #3}
\newcommand{\When}[3]{#1 \; \mybox{when} \; #2(#3)}
\newcommand{\Merge}[5]{\mybox{merge} \; #1 \; (#2 \Rightarrow #3) \; \dots \; \
  (#4 \Rightarrow #5)}
\newcommand{\Merges}[5]{\mybox{merge} \; #1 \; (#2 \Rightarrow #3) \; \
  (#4 \Rightarrow #5)}
\newcommand{\Base}[0]{\mybox{base}}
\newcommand{\On}[3]{#1 \; \mybox{on} \; #2 (#3)}
\newcommand{\Map}[3]{\mathtt{map} \; #1 n (#2,\dots,#3)}
\newcommand{\Fold}[3]{\mathtt{fold} \; #1 n (#2,\dots,#3)}
\newcommand{\Mapfold}[3]{\mathtt{mapfold} \; #1 n (#2,\dots,#3)}

%% Syntaxe VHDL

\newcommand{\Component}[6]{\mybox{component} \; #1 \; \mybox{port} \; #2 \; \
  \mybox{with} \; \mybox{sig} \; #3 \; \mybox{and} \; \mybox{var} \; #4 \; \\
  \mybox{and} \; \mybox{subcomponents} \; #5 \; \mybox{in} \; #6}

\newcommand{\Assign}[2]{#1 \Leftarrow #2}
\newcommand{\Affect}[2]{#1 \coloneqq #2}
\newcommand{\Case}[5]{\mybox{case} \; #1 \; \mybox{of} \; (#2 \Rightarrow #3) \
  \dots (#4 \Rightarrow #5)}

\title{Traduction SCADE/Lustre vers VHDL~\thanks{Rapport d'\'etude dans
    le cadre du projet GENCOD}} 
\author{Adrien Guatto et Marc Pouzet
  \\ Universit\'e Pierre et Marie Curie \\
     \'Ecole normale sup\'erieure} 
\date{31 aout 2010}

\begin{document}

\maketitle

\section{Introduction}
Ce document pr\'esente une m\'ethode de compilation de programmes synchrones
\'ecrits dans un langage de type SCADE~6 vers VHDL. Il s'appuie sur la r\'ealisation
d'un prototype r\'ealis\'e au cours du projet et mis \`a la disposition des
autres partenaires de GENCOD. 

Le probl\`eme de la g\'en\'eration de code VHDL \`a partir de SCADE a \'et\'e envisag\'e sous
deux angles:
\begin{itemize}
\item
\end{itemize}

Le code VHDL est obtenu \`a partir du code Le A la diff\'erence de la solution propos\'ee par GeenSoft o\`u la g\'en\'eration de
code VHDL est obtenue \`a partir du code C g\'en\'er\'e par le compilateur KCG de
SCADEA6. Ce prototypune technique de traduction de programmes synchronespr\'esente une m\'ethode de traduction pr\'esente une approche 
On d\'etaille ici la traduction de \LANG{}, un langage synchrone combinant des
\'equations \`a flots de donn\'ees, dans l'esprit de Lustre, et des automates
hi\'erarchiques, tels qu'introduits par Lucid Synchrone et SCADE 6, vers le
langage de description de circuits VHDL. Cette traduction prend le parti de ne
pas passer par un langage imp\'eratif mais de directement utiliser la
repr\'esentation interne \`a flots de donn\'ees du compilateur.

Apr\`es avoir rappell\'e bri\`evement la forme des langages d'entr\'ee et de sortie, on
va expliciter la proc\'edure de traduction retenue.

\section{\LANG}

\LANG{} est un langage synchrone acad\'emique conceptuellement proche de SCADE,
mais un peu moins expressif : pas de signaux, peu de constructions riches
(\'emissions sur transitions, etc.). Par rapport aux it\'erations pr\'ec\'edente, il
dispose d\'esormais de tableaux de taille statique et des it\'erateurs associ\'es.

On va d\'ecrire rapidement quelques exemples illustrant les fonctionnalit\'es du
langage, avant de d\'etailler le processus de compilation et l'architecture du
compilateur.

\subsection{Quelques exemples}

\paragraph{Compteur d'\'ev\'enements simple}

\verbatiminput{simpcount.ept}

Le nœud \textit{count} compte le nombre d'\'ev\`enements \textit{e} re\c{c}us depuis le
premier instant du programme.

\paragraph{Compteur multi-\'ev\'enements r\'einitialisable}

\verbatiminput{compteur.ept}

Ce programme implante un compteur d'\'ev\'enements qui comptabilise le nombre de
bool\'eens valant \texttt{true} sur son entr\'ee \textit{event}, celle-ci étant
un tableau de booléens de taille \textit{n}, où \textit{n} est un paramètre
statiquement connu du noeud. On utilise les it\'erateurs \texttt{map} et
\texttt{fold} pour calculer le nombre d'\'ev\'enements observ\'es dans l'instant
; le premier permet de traduire les bool\'eens en entiers, et le second
d'additioner ceux-ci. Notons \'egalement l'utilisation de la construction de
r\'einitialisation \texttt{reset}, actionn\'ee simplement lorsque l'entr\'ee
\textit{rst} est vraie.

\paragraph{Allocateur de ressource}

\verbatiminput{alloc.ept}

Cet exemple pr\'esente un automate r\'ealisant l'allocation d'une ressource
quelconque \`a deux demandeurs, avec priorit\'e \textit{round-robin} (en cas de
demande simultann\'ee, le processus qui vera sa requ\^etre satisfaite sera celui
ayant obtenu la ressource il y a le plus longtemps).

\subsection{Architecture du compilateur}

On d\'ecrit bri\`evement l'architecture du compilateur : apr\`es des phases initiales
d'analyse lexicale, syntaxique et de typage, le programme \LANG{} est soumis aux
v\'erifications traditionnelles des langages synchrones (causalit\'e,
etc.). Ensuite, la compilation progresse par étapes successives en réécrivant le programme jusqu'\`a arriver \`a une forme simple qui
peut \^etre traduite simplement en MiniLS. Le code r\'esultant, apr\`es avoir \'et\'e
soumis \`a d'\'eventuelles optimisations, est mis dans une certaine forme dite
``normale'' et ordonnanc\'e avant d'\^etre finalement traduit en code
s\'equentiel. L'architecture du compilateur \LANG{} est pr\'esent\'e \`a la figure
\ref{fig:archi}. Le processus de compilation de MiniLS vers un langage impératif séquentiel est
d\'ecrit en d\'etails dans l'article \cite{lctes08a}.

% Le compilateur est structur\'e en plusieurs passes effectuant une combinaison
% d'analyses et de transformations, g\'en\'eralement dans le but d'obtenir un code
% imp\'eratif bas-niveau compilable avec les outils idoines. On d\'etaille bri\`evement
% ces diff\'erentes passes, d'abord dans le cas de la compilation traditionnelle
% (cercles verts du sch\'ema) vers un langage imp\'eratif, puis lorsque la cible est
% VHDL (cercles bleus). Les \'etapes quatre \`a sept sont d\'ecrites dans l'article
% \cite{lucy:lctes08a}.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=0.5]{archi}
  \caption{Architecture du compilateur \LANG}
  \label{fig:archi}
\end{figure}

Le passage au code s\'equentiel est court-circuit\'e lors d'une compilation vers
VHDL, qui traduit MiniLS directement vers celui-ci. Pour faciliter cette \'etape,
on pratiquera en amont trois transformations simplificatrices sur MiniLS.

\renewcommand{\labelenumi}{\Alph{enumi}}
\begin{enumerate}
\item Suppression de la r\'einitialisation logique.
\item Suppression des it\'erateurs sur tableaux via mise \`a plat.
\item Introduction d'une variable interm\'ediaire pour chaque argument d'un appel
  de noeud.
\end{enumerate}

Le code obtenu sera finalement traduit vers un sous ensemble de VHDL baptis\'e
MiniVHDL (étape D), prêt à \^etre trait\'e par les outil d\'edi\'es (étape E).

\section{De \LANG{} \`a VHDL}

\subsection{Langages internes}

\subsubsection{MiniLS}
\label{sec:syn:mls}

\begin{figure}[h]
  \centering
  \begin{eqnarray*}
    td & \Coloneqq & \mybox{type } bt = C + \dots + C \\
    d & \Coloneqq & \Node{p}{p}{p}{D} \\
    p & \Coloneqq & x : bt; \dots; x : bt \\
    D & \Coloneqq & pat = e; \dots; pat = e \\
    pat & \Coloneqq & x \p (pat,\dots,pat) \\
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \Fby{v}{e} \p \Pre{e} \\
    & \p & \Every{f}{e}{e}{x} \p \When{e}{C}{x} \\
    & \p & \Merge{x}{C}{e}{C}{e} \\
    & \p & \Map{f}{e_1}{e_n} \\
    & \p & \Fold{f}{e_1}{e_n} \\
    & \p & \Mapfold{f}{e_1}{e_n} \\
    v & \Coloneqq & i \p C \\
    ck & \Coloneqq & \Base \p \On{ck}{C}{x}
  \end{eqnarray*}
  \caption{MiniLS}
  \label{fig:mls}
\end{figure}

MiniLS est \'equivalent au langage synchrone \`a flots de donn\'ees Lustre
\cite{lustre}, auquel on adjoint une construction de r\'einitialisation
modulaire d'un noeud\footnote{$\Every{f}{e_1}{e_n}{z}$ appelle le noeud $f$ avec
  les arguments $e_1,\dots,e_n$, et r\'einitialise la m\'emoire de celui-ci
  lorsque $z$ est vraie.}. Un programme MiniLS passera successivement par trois
formes distinctes lors du processus de compilation :

\begin{itemize}
\item La forme originale \ref{fig:mls} telle qu'obtenue \`a partir du code
  \LANG{} original. Cette forme est décrite ici par souci de cohérence et ne
  nous intéresse pas directement.
\item La forme normale \ref{fig:mlsn}. Des transformations décrites ci-dessous
  seront effectuées sur celle-ci pour faciliter la traduction vers VHDL.
\item La forme finale \ref{fig:mlsns}, normalis\'ee, sans r\'einitialisations
  ($every$) ni it\'erateurs, et o\`u tous les param\`etres effectifs sont des
  identifiants.
\end{itemize}

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \When{e}{C}{x} \\
    ce & \Coloneqq & e \p \Merge{x}{C}{ce}{C}{ce} \\
    eq & \Coloneqq & x = ce \p x = \Fby{v}{e} \p x = \Pre{e} \\
    & \p & (x,\dots,x) = \Every{f}{e}{e}{x} \\
    & \p & (x,\dots,x) = \App{f}{e,\dots,e} \\
    & \p & \Map{f}{e_1}{e_n} \\
    & \p & \Fold{f}{e_1}{e_n} \\
    & \p & \Mapfold{f}{e_1}{e_n}
  \end{eqnarray*}
  \caption{MiniLS normalis\'e}
  \label{fig:mlsn}
\end{figure}

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \When{e}{C}{x} \\
    ce & \Coloneqq & e \p \Merge{x}{C}{ce}{C}{ce} \\
    eq & \Coloneqq & x = \Pre{e} \\
    & \p & (x,\dots,x) = \App{f}{x,\dots,x}
  \end{eqnarray*}
  \caption{MiniLS simplifi\'e (et normalis\'e)}
  \label{fig:mlsns}
\end{figure}

MiniLS est donc un langage à flots de données proche de Lustre dont les
programmes sont d'équations mutuellement récursives. Ces équations calculent des
suites infinies de valeurs progressant selon un temps découpé en instants
discrets.  Les paquets d'équations sont regroupés dans des unités lexicales
nommées ``noeuds'' à la granularité dans l'esprit d'une fonction d'un langage
impératif tel que C.

On associe à chaque expression du langage un type, qui précise la nature des
valeurs calculées, ainsi qu'une horloge, garde booléenne qui spécifie les
instants durant lesquels l'expression calcule une valeur définie.

Les expressions simples du langage s'exécutent uniquement dans l'instant, et
n'ont pas d'effet en dehors de celui-ci.

\[
\begin{array}{|r|llllllllllllllllllllllllllll}
  \hline
  1     & 1 & 1 & 1 & 1 & \dots \\
  \hline
  1 + 2 & 3 & 3 & 3 & 3 & \dots \\
  \hline
\end{array}
\]

À l'inverse, les expressions \textrm{pre} et \textrm{fby} permettent de retarder
leur argument d'un instant, avec une valeur d'initialisation dans le cas de
\textrm{fby}.

\[
\begin{array}{|r|llllllllllllllllllllllllllll}
  \hline
  1 \ \mathrm{fby} \ 2 & 1 & 2 & 2 & 2 & \dots \\
  \hline
  \mathrm{pre} \ 3 &  & 3 & 3 & 3 & \dots \\
  \hline
\end{array}
\]

Les expressions \texttt{when} et \texttt{merge} permettent respectivement de
sous-échantilloner et sur-échantilloner des expression. L'emploi de ces
constructions a un effet sur les horloges : l'horloge de $\When{e}{C}{x}$ est
$\On{ck}{C}{x}$, où $ck$ est celle de $e$, et l'horloge de
$\Merge{x}{C_1}{e_1}{C_n}{e_n}$ est $ck$ quand celle des $e_i$ est
$\On{ck}{C}{x}$.

\[
\begin{array}{|r|llllllllllllllllllllllllllll}
  \hline
  x & 1 & 2 & 3 & 4 & \dots \\
  \hline
  h & false & true & false & true & \dots \\
  \hline
  \When{x}{true}{h} & & 2 & & 4 & \dots \\
  \hline
  u &  & 1 & & 4 & \dots \\
  \hline
  v & 0 & & 3 & & \dots \\
  \hline
  \Merges{h}{true}{u}{false}{v} & 0 & 1 & 3 & 4 \\
  \hline
\end{array}
\]

Les itérateurs \texttt{map}, \texttt{fold}, et \texttt{mapfold} prennent en
argument une fonction $f$, une taille de tableau et un ou plusieurs
tableaux. Ces constructions ont le même sens que dans les langages de
programmation fonctionnels habituels.

\begin{itemize}
\item \texttt{map} applique en parallèle $f$ à tous les éléments des tableaux
  pour former un nouveau tableau.
\item \texttt{fold} applique en série $f$ sur tous les éléments d'un tableau en
  passant un accumulateur et renvoie ce dernier une fois le parcours terminé.
\item \texttt{mapfold}, qui suppose que $f$ renvoie au moins deux valeurs,
  combine les deux en construisant un nouveau tableau avec le premier résultat
  de $f$ (à la manière de \texttt{map}) et en passant un accumulateur durant le
  parcours (tout comme \texttt{fold}).
\end{itemize}

Enfin, la construction $f(e,\dots,e) \; \mathtt{every} \; x$ réinitialise
l'appel à $f$ dès que $x$ est vrai.

\subsubsection{MiniVHDL}

MiniVHDL \ref{fig:mvhdl} est un fragment tr\`es restreint de VHDL, suffisant pour
d\'ecrire l'essence de notre processus de traduction. Un composant MiniVHDL
$\Component{f}{P}{sigs}{lvars}{ports}{I}$ correspondra concr\`etement \`a un
composant VHDL form\'e des instantiations $ports$, signaux internes $sigs$ et d'un
processus avec les variables locales $lvars$ et de corps $I$.

Le langage est structuré sous forme de composants. Chacun d'eux possède des
signaux d'entrée/sortie, des signaux locaux, des variables locales, d'éventuels
sous-composants, et enfin un corps formé d'une suite d'instructions.

La sémantique informelle du langage est la suivante : dès que la valeur d'un
signal d'entrée ou local change, le corps du composant est exécuté. Celui-ci
peut modifier la valeur d'autres signaux via l'instruction $x \Leftarrow e$ ($x$
étant par définition un signal), entraînant ainsi l'activation de
sous-composants, ou même la réactivation du composant courant. Les variables
locales sont semblables aux variables des langages de programmation
traditionnels : elles n'ont de valeur que pendant l'exécution du corps d'un
composant. L'exécution s'arrête une fois tous les signaux stables.

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    component & \Coloneqq & \mybox{component} \; f \; \mybox{port} \; sm;\dots;\
    sm \; \mybox{with} \, \mybox{sig} \; d; \dots; d \; \\
    & & \mybox{and} \, \mybox{var} \; d; \dots; d \; \mybox{and} \
    \mybox{subcomponents} \; p; \dots; p \; \mybox{in} \; I \\
    sm & \Coloneqq & x : mode \ ty \\
    sd & \Coloneqq & x : mode \ ty := e \\
    mode & \Coloneqq & \mybox{in} \p \mybox{out} \\
    d & \Coloneqq & x : ty \\
    p & \Coloneqq & \mybox{port map } x (bd;\dots;bd) \\
    bd & \Coloneqq & x \Rightarrow x \\
    I & \coloneqq & i; \dots; i \\
    i & \Coloneqq & \Assign{x}{e} \p \Affect{x}{e} \p \Case{e}{v}{I}{v}{I} \\
    e & \Coloneqq & id \; \vert \; v \; \vert \; \Op{e}{e} \\
    v & \Coloneqq & i \; \vert \; ' bitp ' \\
    bitp & \Coloneqq & bit \p bit \  bitp \\
    bit & \Coloneqq & \mathbf{0} \p \mathbf{1} \\
    bt & \Coloneqq & \mybox{natural} \p \mybox{std\_logic} \p \mybox{bit}
    \p \dots
  \end{eqnarray*}
  \caption{MiniVHDL}
  \label{fig:mvhdl}
\end{figure}

Notons que les param\`etres effectifs des sous-composants sont des noms de
signaux ; cela justifie la forme simplifi\'ee MiniLS d\'ecrite au paragraphe
pr\'ec\'edent.

\subsection{Simplification de MiniLS normalis\'e}

Nous effectuons donc trois passes pour simplifier le code MiniLS.

\subsubsection{\'Elimination de la r\'einitialisation logique}

Comme expliqué plus haut, certaines constructions de MiniLS proposent au
programmeur une forme de r\'einitialisation modulaire : les \'equations de la
forme $\Fby{v}{e}$ d'un noeud $f$ instanci\'e par la construction
$\Every{f}{e_1}{e_n}{z}$ doivent-\^etre r\'einitialis\'ees d\`es lors que $z$
est vrai.

La premi\`ere passe de simplification, qui s'ex\'ecute sur le code MiniLS obtenu
\`a la troisi\`eme \'etape du processus d\'ecrit plus haut, va exprimer la
réinitialisation en fonction du reste du langage, réduisant ainsi la complexité
du langage à traduire vers VHDL.

On va supposer dans ce qui suit que l'identifiant \textbf{rst} est un
identifiant utilisé nulle part dans le programme. En pratique, le compilateur
s'assure de l'absence de conflit avec les variables de l'utilisateur.

L'id\'ee est d'ajouter \`a chaque noeud un argument suppl\'ementaire nomm\'e
\textbf{rst} qui vaudra $true$ lorsqu'une r\'einitialisation de la m\'emoire est
nécessaire, et de modifier les expressions contenant des constructions
\texttt{fby} ou \texttt{every} pour prendre en compte \textbf{rst}. L'exemple
suivant reprend le compteur simple présenté plus haut pour illustrer cette
simplification.

\verbatiminput{rst_ex.ept}

Une fois le reset éliminé, le code est le suivant :

\verbatiminput{rst_ex2.ept}

On va détailler les fonctions effectuant ces deux t\^aches : $RstE(e)$ prend une
expression MiniLS $e$ et renvoie une nouvelle expression où la réinitialisation
a été éliminée, et $RstNode(nd)$ prend un nœud $nd$ et renvoie un nouveau nœud
prenant un \texttt{rst} \`a un noeud et transforme ses \'equations.

\newcommand{\re}[1]{RstE(#1)}
\newcommand{\rstn}[1]{RstNode(#1)}

\[
\begin{array}{lcl}
  \re{\Op{e_1}{e_n}} & = & \Op{\re{e_1}}{\re{e_n}} \\
  \re{\Fby{v}{e}} & = & \If{rst}{v}{(\Fby{v}{\re{e}})} \\
  \re{\Pre{e}} & = & \Pre{\re{e}} \\
  \re{\Every{f}{e_1}{e_n}{x}} & = & \App{f}{\mathbf{rst} \; \mathtt{or} \;
    x, \re{e_1} \dots, \re{e_n}} \\
  \re{\App{f}{e_1,\dots,e_n}} & = &
  \App{f}{\mathbf{rst},\re{e_1},\dots,\re{e_n}} \\
  \re{\If{e_1}{e_2}{e_3}} & = & \If{\re{e_1}}{\re{e_2}\\ & & \hspace{1.9cm}}
  {\re{e_3}} \\
  \re{\When{e}{C}{x}} & = & \When{\re{e}}{C}{x} \\
  \re{\Merge{e}{C_1}{e_1}{C_n}{e_n}} & = &
  \mybox{merge} \; \re{e} \; (C_1 \Rightarrow \re{e_1}) \\
  & & \hspace{2.4cm} \dots \\
  & & \hspace{2.4cm} (C_n \Rightarrow \re{e_n})
\end{array}
\]

\[
\begin{array}{ll}
  RstEqs(pat_1 = e_1;\dots;pat_n = e_n) & = \\
  \ind pat_1 = \re{e_1};\dots;pat_n = \re{e_n} \\
  \rstn{\Node{f}{x_1,\dots,x_n}{y_1,\dots,y_n}{eqs}} & = \\
  \ind \Node{f}{rst,x_1,\dots,x_n}{y_1,\dots,y_n}{ResetEqs(eqs)}
\end{array}
\]

\subsubsection{Suppression des it\'erateurs}

La version actuelle du compilateur et de son g\'en\'erateur de code VHDL supporte
les tableaux de dimension arbitraire \footnote{En pratique, les outils de
  synth\`ese de circuits \`a partir de code VHDL imposent une dimension maximale.}
et constructions associ\'ees ; il nous faut donc compiler les it\'erateurs
\texttt{map}, \texttt{fold} et \texttt{mapfold} vers VHDL.

Par souci de simplicit\'e et uniformit\'e, nous avons fait le choix de les \'eliminer
par \textit{inlining} lors d'une transformation source-\`a-source sur MiniLS. On
ne d\'etaillera pas cette op\'eration qui consiste simplement \`a remplacer les
it\'erateurs par plusieurs \'equations. L'\'equation $x = \Map{f}{t_1}{t_m}$ lorsque
les tableaux $t_1, \dots, t_m$ sont de taille $n$ sera ainsi remplac\'ee par $n +
1$ \'equations dont les $n$ premi\`eres effectuent l'application de $f$ pour chaque
indice et la derni\`ere affecte \`a $x$ le tableau en r\'esultant. On applique des
transformations similaires aux op\'erateurs \texttt{fold} et \texttt{mapfold}.

Le programme suivant pr\'esente un exemple effectuant un ET logique sur tous les
\'el\'ements d'un tableau via l'it\'erateur \texttt{fold}.

\verbatiminput{fold_orig.ept}

Son pendant avec it\'erateur mis \`a plat se contente de passer l'accumulateur
d'\'el\'ement en \'el\'ement.

\verbatiminput{fold_il.ept}

Un traitement spécial est adopté pour l'utilisation de \texttt{map} avec
certains opérateurs. En effet, VHDL permet d'utiliser certains opérateurs sur
des tableaux de bits, sans avoir à déconstruire ces derniers ; par exemple, il
est possible d'effectuer un ET logique bit-à-bit sur deux tableaux $t_1$ et
$t_2$ via $t_1 \ \texttt{and} \ t_2$. La passe effectue la transformation de
$\texttt{map}\ \textbf{op}<<n>>(t_1,\dots,t_n)$ à $t_1\ \textbf{op}\ \dots
\textbf{op}\ t_n$ lorsque cela est possible.

\subsubsection{Simplification des appels}

\newcommand{\simpl}[2]{Simpl(#1,#2)}
\newcommand{\simplnd}[1]{SimplNode(#1)}

Comme nous le verrons plus bas, les appels de nœuds seront compil\'es en
instantiations de composants ; or, les arguments d'une construction VHDL $port
\; map$ sont forc\'ement des identifiants. Pour simplifier la génération de
VHDL, on va donc modifier en amont chaque appel de noeud en introduisant une
variable interm\'ediaire pour chaque argument. La fonction $\simpl{eq}{eqs}$
simplifie l'équation $eq$ en ajoutant la ou les équations produits à la liste
des équations déjà traitées $eqs$ ; $\simplnd{nd}$ prend un noeud $nd$ et
simplifie les appels présents dans ses équations.

\[
\begin{array}{ll}
  \simpl{x = ce}{eqs} & = \\
  \ind (x = ce) \Cons eqs \\
  \simpl{x = \Pre{e}}{eqs} & = \\
  \ind (x = \Pre{e}) \Cons eqs \\

  \simpl{(x_1,\dots,x_n) = \App{f}{e_1,\dots,e_n}}{eqs} & = \\
  \ind (y_1 = e_1) \Cons \dots \Cons (y_n = e_n)
  \Cons ((x_1,\dots,x_n) = \App{f}{rst,y_1,\dots,y_n}) \Cons eqs \\
  \ind \mbox{o\`u } y_1,\dots,y_n \mbox{ sont des noms de variables frais}
\end{array}
\]

\[
\begin{array}{ll}
  \simplnd{\Node{x_1,\dots,x_n}{y_1,\dots,y_n}{p}{D}} & = \\
  \ind \mathtt{node} f(x_1,\dots,x_n) = y_1, \dots, y_n \; \\
  \ind \mathtt{with} \  \mathtt{var} \; p' \; \mathtt{in} \; fold\_right \;Simpl
  \; D \; [] \\
  \ind \mbox{en supposant que que } p' \mbox{ correspond}
  \mbox{aux variables d\'efinies par} \\ \ind \mbox{les nouvelles \'equations.}
\end{array}
\]

Ces simplifications effectu\'ees, on va s'atteler \`a la traduction de MiniLS vers
MiniVHDL.

\subsection{MiniLS simplif\'e vers MiniVHDL}

Les id\'ees g\'en\'erales de la traduction de MiniLS simplifi\'e vers MiniVHDL sont les
suivantes :

\begin{itemize}
\item Chaque noeud MiniLS correspondra \`a un composant (Mini)VHDL.
\item Chaque \'equation \`a m\'emoire (i.e. contenant $fby$ ou $pre$) va correspondre
  \`a un signal VHDL local, chaque \'equation combinatoire \`a une variable locale.
\item Les horloges importent uniquement pour les équations de la forme $x =
  \Fby{v}{e}$ et $(x_1,\dots,x_n) = \App{f}{e_1,\dots,e_n}$ : il faudra alors
  générer la garde booléenne correspondant à $ck$. Les autres sont combinatoires
  et ne nécessitent pas de traitement particulier.
\item La r\'einitialisation logique est g\'er\'ee en amont comme expliqu\'ee ci-dessus,
  elle est donc implicitement asynchrone (ind\'ependante des fronts montants de
  l'horloge).
\item Les partenaires ont exprim\'e le d\'esir de pouvoir r\'einitialiser
  physiquement toute la m\'emoire lors du bascument d'un signal pr\'ecis nomm\'e
  \textbf{hwrst} : on ajoute donc ce signal suppl\'ementaire invisible dans le
  code MiniLS et on g\'en\`ere le code de r\'einitialisation correspondant lors
  du traitement du $fby$. Tout comme pour l'identifiant \textit{rst} plus haut, on suppose que l'identifiant \textbf{hwrst} n'est pas utilisé dans le programme.
\item Pour respecter la s\'emantique \`a $\Delta$-cycles de VHDL, il importe de
  faire \'evoluer la m\'emoire par un pas du calcul uniquement sur front montant de
  l'horloge.
\item En suivant le mod\`ele synchrone, les valeurs calcul\'ees par le circuit \`a
  d'autres moments que le front montant n'ont pas de sens bien d\'efini ; on les
  ignorera donc.
\item Chaque appel de noeud correspondra \`a une instantiation. Comme sp\'ecifi\'e
  plus haut, les param\`etres effectifs d'un signal VHDL sont obligatoirement des
  signaux auxquels il faudra assigner la valeur correcte.
\end{itemize}

\subsubsection{Traduction des types}

Les d\'eclarations de types de donn\'ees ont \'et\'e laiss\'ees implicites aussi bien dans
la syntaxe de MiniLS que de MiniVHDL ; les possibilit\'es \'etant exactement les
m\^emes (\'enum\'erations et enregistrements), on choisit de ne pas s'attarder sur
leur traduction qui reste une traduction mot-\`a-mot d'une syntaxe concr\`ete \`a
l'autre.

\subsubsection{Traduction des constantes et fonction auxiliaires sur les horloges}

La fonction $TradConst(c)$ traduit une constante MiniLS $c$ en constante
MiniVHDL.

\newcommand{\TradC}[1]{TradConst(#1)}

\[
\begin{array}{lcl}
  \TradC{i} & = & i \\
  \TradC{true} & = & '1' \\
  \TradC{false} & = & '0' \\
  \TradC{C} & = & C
\end{array}
\]

La fonction auxiliaire $GuardClock$ permet de traduire une horloge MiniLS en
expression MiniVHDL de type bool\'een. Elle sera utilis\'ee pour contr\^oler la
mise \`a jour des registres, s'assurant que cette derni\`ere n'est effectu\'ee
qu'aux instants o\`u l'horloge est effective.

\newcommand{\GEC}[1]{GuardClock(#1)}

\[
\begin{array}{lcl}
  \GEC{\Base} & = & rising\_edge(clk) \\
  \GEC{\On{ck}{C}{x}} & = & x = \TradC{C} \; \mathtt{and} \; \GEC{ck}
\end{array}
\]

Tout comme les mises \`a jour des m\'emoires, les appels \`a d'autres noeuds
sont dirig\'es par les horloges qui en donnent la cadence. Il nous faudra donc
une fonction voisine de $GuardClock$ pour calculer l'expression MiniVHDL
correspondant \`a l'horloge utilis\'ee dans l'appel d'un noeud.

\newcommand{\EC}[1]{ExpClock(#1)}

\[
\begin{array}{lcl}
  \EC{\Base} & = & clk \\
  \EC{\On{ck}{C}{x}} & = & x = \TradC{C} \; \mathtt{and} \; \EC{ck}
\end{array}
\]

\subsubsection{Traduction des expressions et \'equations}

La fonction $TradExp(e)$ traduit l'expression MiniLS normalis\'ee et
simplifi\'e $e$ en expression MiniVHDL.

\newcommand{\TradE}[1]{TradExp(#1)}

\[
\begin{array}{lcl}
  \TradE{v} & = & \TradC{v} \\
  \TradE{x} & = & x \\
  \TradE{\Op{e_1}{e_n}} & = & \Op{\TradE{e_1}}{\TradE{e_n}} \\
  \TradE{\When{e}{C}{x}} & = & \TradE{e}
\end{array}
\]

La construction \texttt{when} n'a pas de sens calculatoire, et peut n'être vue
que comme une annotation d'horloge. Elle sera ignorée lors du processus de
traduction.

La fonction $TradCExp(ce)$ traduit les expressions $ce$ de contr\^ole form\'ees
d'expressions simples ou de \texttt{merge} imbriqu\'es en instructions MiniVHDL.

\newcommand{\TradCE}[2]{TradCExp(#1, #2)}

\[
\begin{array}{ll}
  \TradCE{x}{\Merge{y}{C_1}{ce_1}{C_n}{ce_n}} & = \\
  \ind \mathtt{case} \; y \; \mathtt{of} \;
  (\TradC{C_1} \Rightarrow \TradCE{x}{ce_1}) \\
  \hspace{2.1cm} \dots \\
  \hspace{2.1cm} (\TradC{C_n} \Rightarrow \TradCE{x}{ce_n}) \\
  \TradCE{x}{e} & = \\
  \ind \Affect{x}{\TradE{e}}
\end{array}
\]

Enfin, la fonction $TradEq$ permet de passer des \'equations aux instructions
MiniVHDL. Elle prend un argument suppl\'ementaire permettant de compter le nombre
d'appels de noeuds afin de g\'en\'erer des arguments suppl\'ementaires, et on se donne
une fonction suppl\'ementaire $MakeArg(x,i)$ qui g\'en\`ere un nom de variable frais \`a
partir du nom de variable $x$ et de l'entier $i$.

La traduction des \'equations appelant un noeud n\'ecessite des explications
concernant la fa\c{c}on de compiler les appels d'un noeud MiniLS qui seront donn\'ees
\`a la section suivante.

\newcommand{\TradEq}[2]{TradEq(#1,#2)}
\newcommand{\MA}[2]{MakeArg(#1,#2)}

\[
\begin{array}{lcl}
  \TradEq{x = ce}{i} & = & \TradCE{x}{ce}, i \\

  \TradEq{x = \Pre{e}}{i} & = & \mathtt{if} \; \GEC{ck} \; \mathtt{then} \\
  & & \ind \Assign{x}{\TradE{e}} \\
  & & \mathtt{end} \; \mathtt{if}, i \\

  \TradEq{x = \Fby{y}{e}}{i} & = & \mathtt{if} \; \mathbf{hwrst}
  \; \mathtt{then} \\
  & & \ind \Assign{x}{y} \\
  & & \mathtt{elsif} \; \GEC{ck} \; \mathtt{then} \\
  & & \ind \Assign{x}{\TradE{e}} \\
  & & \mathtt{end} \; \mathtt{if}, i \\


  \TradEq{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}}{n} & = &
  \Assign{\MA{"ck"}{i}}{\EC{ck}} \\
  & & \Assign{\MA{y_1}{i}}{y_1} \\
  & & \dots \\
  & & \Assign{\MA{y_n}{i}}{y_n}, i + 1 \\
\end{array}
\]

Pr\'ecisons que par construction, l'interface d'un composant est toujours de la
forme $(clk, in_1, \dots,in_n, out_1,\dots,out_n)$.

\subsubsection{Gestion des tableaux}

Hormis le cas des it\'erateurs trait\'es pr\'ec\'edemment, la gestion des
tableaux n'appelle pas de commentaire particulier, \`a l'exception de la
n\'ecessit\'e de d\'eclarer \`a l'avance les types tableaux (bornes exclues) en
VHDL. Deux solutions sont envisageables :

\begin{itemize}
\item Calculer la dimension maximale des tableaux rencontr\'es dans le programme,
  et utiliser cette information pour pr\'e-d\'eclarer les tableaux VHDL idoines.
\item D\'eclarer quoi qu'il advienne les types de tableaux utiles et refuser les
  programmes comprenant des dimensions sup\'erieures \`a une limite fix\'ee \`a l'avance
  .
\end{itemize}

Le compilateur emploie pour l'instant la premi\`ere m\'ethode, mais la seconde ne
nous semble pas d\'erangeante pour des raisons pragmatiques\footnote{Notons que
  notre version de l'outil Xilinx ISE refuse par exemple tout tableau de
  dimension sup\'erieure \`a trois.}.

\subsubsection{Compilation modulaire et appels de noeuds}

MiniVHDL offre une forme de modularit\'e bas\'ee sur une hi\'erarchie de
composants. Chacun de ces derniers sp\'ecifie une liste de composants fils dont
les ports (au sens de la figure \ref{fig:mvhdl}) sont instanci\'es avec des
signaux. Nous prenons donc soin d'utiliser des signaux comme r\'esultats mais
aussi arguments ; par souci de simplicit\'e, on introduit des signaux locaux pour
chaque argument, signaux qui seront affect\'es lors de la traduction de l'\'equation
correspondant \`a l'appel de noeud original.

La fonction $GatherPortMaps(D, i)$ rassemble cette liste de sous-noeuds \`a partir
des appels de noeud pr\'esents dans le paquet d'\'equations $D$ et cr\'e\'e les
instantiations de composants correspondantes. L'entier $i$ nous servira \`a
distinguer les appels de noeuds et de cr\'eer de nouveaux noms de signaux frais
gr\^ace \`a la fonction $MakeArg$ d\'ecrite plus haut. On se donne \'egalement une
fonction $GetArgName(f,n)$ qui renvoie le nom du $n$-\`eme argument du noeud de
nom $f$.

\newcommand{\GPM}[2]{GatherPortMaps(#1,#2)}
\newcommand{\GAN}[2]{GetArgName(#1,#2)}

\[
\begin{array}{lcl}
  \GPM{[]}{i} & = & [] \\
  \GPM{((x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}) \Cons eqs}{i} & = &
  \\
  \ind \mybox{port map} \; f ( clk \Rightarrow \MA{"clk"}{i} \\
  \ind \ind \ind \ind \hspace{0.4cm} \GAN{f}{1} \Rightarrow \MA{y_1}{i} \\
  \ind \ind \ind \ind \hspace{0.4cm} \dots \\
  \ind \ind \ind \ind \hspace{0.4cm} \GAN{f}{n} \Rightarrow \MA{y_n}{i}) \\
  \ind \Cons \GPM{eqs}{i + 1}
\end{array}
\]

On d\'efinit ensuite les fonctions auxiliaires $NeedVar$, $Vars$, $ParamSigs$ et
$SignalOfVarDec$ respectivement charg\'ees de d\'eterminer si une \'equation introduit
des d\'eclarations de variables locales ou non, de calculer la liste des variables
d\'efinies par une \'equation, de calculer les signaux \`a passer en arguments aux
appels de noeuds pr\'esents dans un paquet d'\'equations et enfin de traduire
simplement une d\'eclaration de variable MiniLS en d\'eclaration de signal MiniVHDL
avec mode d'utilisation (entr\'ee ou sortie).

\newcommand{\NV}[1]{NeedVar(#1)}
\newcommand{\V}[1]{Vars(#1)}
\newcommand{\PS}[2]{ParamSigs(#1,#2)}
\newcommand{\SoVD}[3]{SignalOfVarDec(#1 : #2, #3)}

\[
\begin{array}{lcl}
  \NV{x = \Fby{v}{e}} & = & false \\
  \NV{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}} & = & false \\
  \NV{x = ce} & = & true
\end{array}
\]

\[
\begin{array}{lcl}
  \V{x = \Fby{v}{e}} & = & [x] \\
  \V{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}} & = & x_1 \Cons \dots \Cons x_n \\
  \V{x = ce} & = & [x]
\end{array}
\]

\[
\begin{array}{ll}
  \PS{x = \Fby{v}{e} \Cons eqs}{i} & = \\
  \ind \PS{eqs}{i} \\
  \PS{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n} \Cons eqs}{i} & = \\
  \ind \MA{"clk"}{i} \Cons \MA{y_1}{i} \Cons \dots \Cons \MA{y_n}{i} \\
  \ind \mathtt{::} \; \PS{eqs}{i + 1}
  \\
  \PS{x = ce \Cons eqs}{i} & = \\
  \ind \PS{eqs}{i}
\end{array}
\]

\[
\begin{array}[lcl]{lcl}
  \SoVD{x}{bt}{mode} & = & \mybox{signal} \; x : mode \; TransBaseType(bt)
\end{array}
\]

\subsubsection{Traduction des noeuds}

Enfin, $TradNode(nd)$ se charge de traduire un noeud $nd$ en composant MiniVHDL, en
cr\'eant un signal local pour chaque \'equation retard\'ee et argument d'appel de
noeud, une variable pour chaque \'equation combinatoire, et la liste de
sous-composants requise.

\begin{align*}
  & TradNode(\mybox{node } f(in) = out \mybox{ with var } p \mybox{ in } D) = \\
  & \bl \mbox{soit } port = \\
  & \bl \bl clk : \mybox{in std\_logic}; \\
  & \bl \bl \{ SignalOfVarDec(x : bt, \mybox{in}) \p (x : bt) \in in \}; \\
  & \bl \bl \{ SignalOfVarDec(x : bt, \mybox{out}) \p (x : bt) \in out \}, \\
  & \bl \mbox{ soit } signals = \{ \V{eq} \p eq \in D, \neg \NV{eq} \}
  \mybox{,} \\
  & \bl \mbox{ soit } sig\_args = \PS{D}{1} \mybox{,} \\
  & \bl \mbox{ soit } variables = \{ \V{eq} \p eq \in D, \NV{eq} \} \mybox{,} \\
  & \bl \mbox{ soit } ports = \GPM{D}{1} \mybox{,} \\
  & \bl \mbox{ soit } body = fold\_right TradEq D ([], 1) \mbox{ dans} \\
  & \mybox{component } f \mybox{ port } port \mybox{ with sig } signals \cup
  sig\_args \\
  & \mybox{and var } variables \mybox{ and subcomponents } ports \mybox{ in }
  body
\end{align*}

\section{Discussion}

\section{Conclusion}

On a traduit \LANG{} vers VHDL en profitant des forces du mod\`ele synchrone : sa
s\'emantique est bien adapt\'ee \`a une description sous forme de circuits. Le
processus de traduction reste simple et compr\'ehensible gr\^ace aux garanties
offertes par le synchrone : nul besoin d'\'ecrire plusieurs fois dans le m\^eme
\'el\'ement m\'emorisant par cycle.

\newpage

\tableofcontents

\bibliography{biblio}
\bibliographystyle{plain}

\appendix

\newpage

\section{Exemples de code g\'en\'er\'e}

On pr\'esente ici quelques codes g\'en\'er\'es par notre prototype. En l'\'etat
actuel de ce dernier, beaucoup de variables interm\'ediaires inutiles sont
g\'en\'er\'ees ; cela s'explique pour deux raisons :

\begin{itemize}
\item Ces codes représentent des sorties brutes n'ayant subies aucune
  optimisation.
\item Certaines passes du compilateur ont naturellement tendance à introduire
  des variables intermédiaire de façon préventive, simplifiant ainsi leur
  fonctionnement.
\end{itemize}

\subsection{Compteur}

\paragraph{MiniLS initial}

\small
\verbatiminput{compteur2_init.mls}
\normalsize

\paragraph{MiniLS normalis\'e, ordonnanc\'e et simplifi\'e}

Notons que le noeud \textit{compteur} est ici instanci\'e avec son param\`etre
\textit{n} \'egal \`a 4, ceci afin de pouvoir d\'eplier les it\'erateurs.

\small
\verbatiminput{compteur2_sched.mls}
\normalsize

\paragraph{VHDL}

\small
\verbatiminput{compteur2_vhdl.vhd}
\normalsize

\subsection{Allocateur de ressource}

\paragraph{MiniLS initial}

\small
\verbatiminput{al2_init.mls}
\normalsize

\paragraph{MiniLS normalis\'e, ordonnanc\'e et simplifi\'e}

\small
\verbatiminput{al2_sched.mls}
\normalsize

\paragraph{VHDL}

\small
\verbatiminput{al2_vhdl.vhd}
\normalsize

\section{Utilisation du compilateur}

Nous supposerons dans ce manuel que l'archive du compilateur a \'et\'e
d\'ecompress\'ee dans le r\'epertoire \verb/$HEPTDIR/. Cette archive contient le
pr\'esent rapport, un r\'epertoire \texttt{exs/} avec une batterie d'exemples
\LANG{} compil\'es vers VHDL, et un binaire en code-octet pour la machine
abstraite OCaml. Ce dernier peut-\^etre ex\'ecut\'e via \texttt{ocamlrun heptc},
ou bien directement lorsque votre \texttt{ocamlrun} est pr\'esent dans
\texttt{/usr/bin}. Nous supposerons par la suite que c'est le cas et que votre
variable d'environnement \verb/$PATH/ contient \verb/$HEPTDIR//bin.

Pour utiliser le compilateur, il faut tout d'abord renseigner la variable
d'environnement \verb/$HEPTLIB/ sp\'ecifiant au compilateur o\`u trouver la
biblioth\`eque standard.

\begin{verbatim}
$ export HEPTLIB=$HEPTDIR/lib
\end{verbatim}

Vous pouvez ensuite v\'erifier que le compilateur est disponible et fonctionnel
via la commande suivante :

\begin{verbatim}
$ heptc -version
The Heptagon compiler, version 0.4 (wed. aug. 18 11:17:42 CET 2010)
Standard library in [...]
\end{verbatim}

Pour compiler un fichier \LANG, le compilateur doit \^etre invoqu\'e avec l'option
\verb/-target/. Les arguments possibles pour cette option sont :

\begin{itemize}
\item \verb/vhdl/ : g\'en\`ere du code VHDL.
\item \verb/mls/ : g\'en\`ere le code \`a flots de donn\'ees MiniLS interm\'ediaire.
\item \verb/obc/ : g\'en\`ere un code imp\'eratif simple dans le langage id\'ealis\'e Obc.
\item \verb/c/ : g\'en\`ere du code C.
\end{itemize}

Les cibles VHDL et C invoqu\'ees sur un fichier \verb/source.ept/ produisent
respectivement un dossier \verb/source_vhdl/ et \verb/source_c/ qui contiennent
les fichiers sources g\'en\'er\'es. Par exemple :

\begin{verbatim}
$ cat source.ept
node main() returns (o : int)
let
  o = 0 fby (o + 1);
tel
$ heptc -target vhdl source.ept
$ ls source_vhdl
main.vhd  types.vhd
\end{verbatim}

L'option \verb/-s noeud/ permet de g\'en\`erer le code n\'ecessaire \`a un
ex\'ecutable autonome \`a partir d'un fichier source \LANG, c'est \`a dire un
\textit{test-bench} dans le cas de VHDL et une fonction \verb/main()/ en ce qui
concerne C. Voici un exemple d'utilisation de la sortie C :

\begin{verbatim}
$ cat source.ept
node noeud() returns (o : int)
let
  o = 0 fby (o + 1);
tel

node main() returns (o : int)
let
  o = noeud() + 1;
tel
$ heptc -target c -s main source.ept
$ ls source_c
_main.c  _main.h  source.c  source.h  source_types.c  source_types.h
$ cc -Isource_c source_c/*.c -o source
$ ./source 5 # Option indiquant a l'executable genere de s'arreter apres 5 pas
=> 1
=> 2
=> 3
=> 4
=> 5
\end{verbatim}

\section{Grammaire de \LANG}

Cette grammaire de référence explicite la syntaxe du langage Heptagon.

\newcommand{\sdash}{\mbox{-}}
\newcommand{\spow}{\text{\^{ }}}
\newcommand{\piquots}[1]{<<#1>>}

\newcommand{\lp}{\texttt{(}}
\newcommand{\rp}{\texttt{)}}
\newcommand{\lcb}{\texttt{\{}}
\newcommand{\rcb}{\texttt{\}}}

\[
\begin{array}{lcl}
  type & \Coloneqq & \mathtt{int} \p \mathtt{bool} \p \mathtt{float} \p
    {\bf type\sdash{}name} \\
  & | & type \spow{} constant \\

  \\

  constant & \Coloneqq & {\bf constant\sdash{}name} \\
  & | & {\bf integer} \\
  & | & {\bf string} \\
  & | & constant + constant \\
  & | & constant - constant \\
  & | & \dots \\

  \\

  expression & \Coloneqq & constant \\
  & | & {\bf variable\sdash{}name} \\
  & | & expression + expression \p expression - expression \p \dots \\
  & | &
    iterator \  \lp{}iterator\sdash{}argument\rp{}
    \piquots{constant} \lp{}expression^+\rp{}
    \\
  & | &
    {\bf function\sdash{}name} \; static\sdash{}parameters \;
    \lp{}expression,\dots,expression\rp{} \\
  & | & \mathtt{last} \  {\bf variable\sdash{}name} \\
  & | & \mathtt{pre} \  expression \\
  & | & constant \  \mathtt{fby} \  expression \\
  & | & expression \  \texttt{->} \  expression \\
  & | & \lp{}expression,\dots,\ expression\rp{} \\
  & | & expression = expression \\
  & | & \mathtt{if} \ expression \ \mathtt{then} \ expression \ 
    \mathtt{else} \ expression \\
  & | & \lcb{} field\sdash{}def^+ \rcb{} \\
  & | & expression.{\bf field\sdash{}name} \\
  & | & \lcb{} expression
    \ \mathtt{with} \  field\sdash{}def^+ \rcb{} \\
  & | & [ expression, \dots, expression ] \\
  & | & expression \spow{} constant \\
  & | & expression.[constant^+] \\
  & | & expression.[constant \  .. \ constant] \\
  & | & expression.[expression^+] \ \mathtt{default} \  expression \\
  & | & [ expression \ \mathtt{with} \ expression^+ \ = \ expression ] \\
  & | & expression \ @ \ expression \\

  \\

  static\sdash{}parameters & \Coloneqq & \epsilon \\
  & | & \piquots{constant,\dots,constant} \\

  \\

  iterator & \Coloneqq & \mathtt{map} \p \mathtt{fold} \p \mathtt{mapfold} \\
  iterator\sdash{}argument & \Coloneqq &
    {\bf function\sdash{}name} \; static\sdash{}parameters
    \p \mathtt{+} \p \mathtt{-} \p \dots \\

  \\

  field\sdash{}def & \Coloneqq & {\bf field\sdash{}name} = constant
\end{array}
\]

\newcommand{\funo}{fun\sdash{}or\sdash{}node}

\[
\begin{array}{lcl}
  equation & \Coloneqq &
    \mathtt{automaton} \ state\sdash{}handler^+ \ \mathtt{end} \\
  & | & \mathtt{switch} \ expression \ \mathtt{of} \ switch\sdash{}handler^+ \\
  & | & \mathtt{present} \ present\sdash{}handler^+
    optional\sdash{}present\sdash{}handler \\
  & | & \mathtt{reset} \ block \ \mathrm{every} expression \\
  & | & pattern = expression; \\
  pattern & \Coloneqq & {\bf variable\sdash{}name} \\
  & | & \lp{}pattern,\dots,pattern\rp{} \\

  \\

  switch\sdash{}handler &
    \Coloneqq & | \ {\bf constructor\sdash{}name} \ block \\

  \\

  present\sdash{}handler & \Coloneqq &
    | \ expression \  block \\
  optional\sdash{}present\sdash{}handler & \Coloneqq & \epsilon \\
  & | & \mathtt{default} \ present\sdash{}handler \\

  \\
  state\sdash{}handler & \Coloneqq &
    \mathtt{state} \  {\bf state\sdash{}name} \ block
    \ until\sdash{}transitions? \  unless\sdash{}transitions? \\
  until\sdash{}transition & \Coloneqq & \mathtt{until} \ escapes^+ \\
  unless\sdash{}transition & \Coloneqq & \mathtt{unless} \ escapes^+ \\
  escape & \Coloneqq &
    expression \ \mathtt{then} \ {\bf constructor\sdash{}name} \\
    & | & expression \ \mathtt{continue} \ {\bf constructor\sdash{}name} \\

  \\

  block & \Coloneqq & variable\sdash{}declarations \ \mathtt{do} \ equation^* \\
  variable\sdash{}declarations & \Coloneqq & \epsilon \\
  & | & \mathtt{var} \ variable\sdash{}declaration^+ \\
  variable\sdash{}declaration & \Coloneqq & {\bf variable\sdash{}name} \ : type;
    \\

  \\

  \funo{} & \Coloneqq & \funo{}\sdash{}kind \ 
  {\bf \funo{}\sdash{}name}\lp{}variable\sdash{}declarations\rp{} \ \\
  & & \hspace{6.1cm}
    \mathtt{returns} \ \lp{}variable\sdash{}declarations\rp{} \\
  & & \mathtt{var} \ variable\sdash{}declarations \ \mathtt{let} \ equation^*
  \ \mathtt{tel} \\
  \funo{}\sdash{}kind & \Coloneqq & \mathtt{node} \p \mathtt{fun} \\

  \\

  const\sdash{}decl & \Coloneqq & \mathtt{const} \; ident : type = constant \\
  type\sdash{}decl & \Coloneqq & \mathtt{type} \ {\bf type\sdash{}name} \ = \ 
    type\sdash{}decl\sdash{}desc \\
  type\sdash{}decl\sdash{}desc & \Coloneqq & {\bf type\sdash{}name} \\
  & | & \lcb{} {\bf tag\sdash{}name}, \dots, {\bf tag\sdash{}name} \rcb{} \\
  & | & \lcb{} {\bf field\sdash{}name} : {\bf type\sdash{}name},\  \dots,\ 
    {\bf field\sdash{}name} : {\bf type\sdash{}name} \rcb{} \\
  program & \Coloneqq &
    const\sdash{}decl^* \  type\sdash{}decl^* \  \funo{}^*
\end{array}
\]


\end{document}
