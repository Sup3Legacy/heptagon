\documentclass[a4paper]{article}
%\usepackage[frenchb]{babel}
%\usepackage[utf8]{inputenc}
%\usepackage[T1]{fontenc}
%\usepackage{lmodern}
\usepackage{amsmath}
%\usepackage{tikz}
%\usepackage{cite}
\usepackage{hyperref}
%\usepackage{fancyvrb}
%\usepackage{bm}
%\usepackage{pxfonts}
\usepackage{verbatim}
\usepackage{a4wide}
\usepackage{graphicx}

% Alter some LaTeX defaults for better treatment of figures:
% See p.105 of "TeX Unbound" for suggested values.
% See pp. 199-200 of Lamport's "LaTeX" book for details.
% General parameters, for ALL pages:

%\renewcommand{\topfraction}{0.9}  % max fraction of floats at top
%\renewcommand{\bottomfraction}{0.8} % max fraction of floats at bottom


% Parameters for TEXT pages (not float pages):

%\setcounter{topnumber}{2}
%\setcounter{bottomnumber}{2}
%\setcounter{totalnumber}{4}     % 2 may work better
%\setcounter{dbltopnumber}{2}    % for 2-column pages

%\renewcommand{\dbltopfraction}{0.9} % fit big float above 2-col. text
%\renewcommand{\textfraction}{0.07}  % allow minimal text w. figs
% Parameters for FLOAT pages (not text pages):
%\renewcommand{\floatpagefraction}{0.7}  % require fuller float pages
% N.B.: floatpagefraction MUST be less than topfraction !!
%\renewcommand{\dblfloatpagefraction}{0.7} % require fuller float pages

% remember to use [htp] or [htpb] for placement


\newcommand{\FIXME}{\textcolor{red}{FIXME}}
%\newcommand{\TODO}[1]{(\textcolor{red}{TODO} #1)}
\newcommand{\TODO}[1]{}
\newcommand{\LANG}{Heptagon}
\newcommand{\lucy}{Lucid Synchrone}

\newcommand{\bold}[1]{\textbf{#1}}
\newcommand{\p}[0]{\; \vert \;}
\newcommand{\rst}[1]{Rst(#1)}
\newcommand{\rstnd}[1]{RstNode(#1)}
% \newcommand{\rst}[1]{\llbracket #1 \rrbracket^{rst}}
\newcommand{\tvh}[2]{\llbracket #2 \rrbracket^{vhdl\ #1}}
\newcommand{\guardb}[1]{\llbracket #1 \rrbracket^{guard}}
\newcommand{\guard}[2]{\mbox{if } \guardb{#1} \mbox{ then } #2 \mbox{ else }
  \emptyset}
\newcommand{\mybox}[1]{\mbox{\tt{#1}}}
\newcommand{\bl}[0]{\hspace{0.45cm}}
\newcommand{\ind}[0]{\hspace{0.5cm}}
\newcommand{\Cons}[0]{\; \mathbf{::} \;}
\newcommand{\Coloneqq}[0]{::=}
\newcommand{\coloneqq}[0]{::=}
%% Syntaxe MiniLS

\newcommand{\Node}[4]{\mybox{node} \; f(#1) = #2 \; \mybox{with var} \
  #3 \; \mybox{in} \; #4}
\newcommand{\Op}[2]{\mybox{\bf{op}}(#1,\dots,#2)}
\newcommand{\Fby}[2]{#1 \, \mybox{fby}^{ck} \, #2}
\newcommand{\Pre}[1]{\mybox{pre}^{ck} \, #1}
\newcommand{\Every}[4]{#1^{ck}(#2,\dots,#3) \, \mybox{every} \, #4}
\newcommand{\App}[2]{#1^{ck}(#2)}
\newcommand{\If}[3]{\mybox{if} \; #1 \; \mybox{then} \; #2 \; \mybox{else} \; #3}
\newcommand{\When}[3]{#1 \; \mybox{when} \; #2(#3)}
\newcommand{\Merge}[5]{\mybox{merge} \; #1 \; (#2 \Rightarrow #3) \; \dots \; \
  (#4 \Rightarrow #5)}
\newcommand{\Base}[0]{\mybox{base}}
\newcommand{\On}[3]{#1 \mybox{ on } #2 (#3)}
\newcommand{\Map}[3]{\mathtt{map} \; #1 n (#2,\dots,#3)}
\newcommand{\Fold}[3]{\mathtt{fold} \; #1 n (#2,\dots,#3)}
\newcommand{\Mapfold}[3]{\mathtt{mapfold} \; #1 n (#2,\dots,#3)}

%% Syntaxe VHDL

\newcommand{\Component}[6]{\mybox{component} \; #1 \; \mybox{port} \; #2 \; \
  \mybox{with} \; \mybox{sig} \; #3 \; \mybox{and} \; \mybox{var} \; #4 \; \\
  \mybox{and} \; \mybox{subcomponents} \; #5 \; \mybox{in} \; #6}

\newcommand{\Assign}[2]{#1 \Leftarrow #2}
\newcommand{\Affect}[2]{#1 \coloneqq #2}
\newcommand{\Case}[5]{\mybox{case} \; #1 \; \mybox{of} \; (#2 \Rightarrow #3) \
  \dots (#4 \Rightarrow #5)}

\title{Traduction SCADE/Lustre vers VHDL~\thanks{Rapport d'\'etude dans
    le cadre du projet GENCOD.}}  \author{Adrien Guatto et Marc Pouzet
  \\ LRI~\thanks{Marc Pouzet est maintenant professeur \`a l'Universit\'e
    Pierre et Marie Curie et rattach\'e \`a l'\'Ecole normale
    sup\'erieure. Adrien Guatto, \'etudiant de l'Universit\'e Pierre et
    Marie Curie, a effectu\'e son stage dans le cadre du projet.}}
\date{31 aout 2010}

\begin{document}

\maketitle

\section{Introduction}
Ce document pr\'esente le probl\`eme de la compilation d'un langage synchrone
tel que SCADE vers un langage pour le hardware tel que VHDL. Nous d\'ecrivons le
probl\`eme pos\'e, les principales solutions envisag\'ees et la solution propos\'ee par
le LRI.

Ce travail s'est appuy\'e sur la r\'ealisation d'un prototype d'\'etude,
appel\'e \LANG{}. Il s'agit d'un compilateur produisant \`a la fois du
code s\'equentiel (ici, principalement C et Java) et du code VHDL \`a
partir d'un programme synchrone. Le langage d'entr\'ee est un
sous-ensemble de Scade~6 et qui en reprend les principales
constructions: \'equations data-flow, automates hi\'erarchiques et
tableaux. Son compilateur est organis\'e de mani\`ere similaire au
compilateur KCG de Scade d\'evelopp\'e par
Esterel-Technologies~\footnote{Pour \^etre complet, \LANG{} est un
  sous-ensemble du langage \lucy~\cite{lucy:manual06} dont les
  principaux traits sont int\'egr\'es \`a Scade~6. Nous aurions donc pu tout
  aussi bien r\'ealiser un prototype d'\'etude \`a partir de \lucy. Le
  langage \'etant plus riche (ordre sup\'erieur, inf\'erence de type,
  polymorphisme, etc.), cela n\'ecessitait de r\'esoudre des probl\`emes peu
  pertinents pour le projet GENCOD. D'o\`u le choix de r\'ealiser un
  prototype simplifi\'e, plus proche de la structure interne du
  compilateur KCG pour un langage proche de Scade~6.}.  Le prototype
\LANG{} a \'et\'e mis a la disposition des partenaires du projet GENCOD.

\subsection{Compilation de SCADE/Lustre vers VHDL}
Rapellons l'organisation g\'en\'erale du compilateur KCG (Figure~\ref{organisation-scade}).

\begin{figure}
\begin{center}
\includegraphics[height=4cm]{Fig/compil-scade}
\end{center}
\caption{Organisation g\'en\'erale du compilateur de SCADE~\label{organisation-scade}}
\end{figure}

La compilation d'un programme se d\'eroule en quatre grandes \'etapes: 1/
une phase d'analyse statique (typage~\cite{lucy:emsoft03}, calcul
d'horloges~\cite{lucy:emsoft04}, analyse de causalit\'e et analyse
d'initialisation~\cite{lucy:sttt04}); 2/ une phase comportant une
succession de r\'e\'ecritures produisant \`a la fin un code data-flow avec
horloges; 3/ une phase de compilation vers du code imp\'eratif
s\'equentiel (object code) o\`u chaque noeud Scade est repr\'esent\'e
par une fonction de transition; 4/ une phase
d'optimisation appliqu\'ee au code s\'equentiel (\'elimination des copies,
propagation de constantes, etc.). Au pr\'ealable \`a cette phase, les modules
sont expans\'es et le code polymorphe est sp\'ecialis\'e. Ces deux \'etapes ne sont pas
d\'ecrites ici.

Au regard de cette organisation, il y a deux points d'entr\'ees naturels pour produire du
code VHDL:
\begin{itemize}
\item
\`a partir du code interm\'ediaire dataflow avec horloges, apr\`es \'elimination des
structures de contr\^ole (e.g., automates, conditions d'activation);
\item
\`a partir du code final g\'en\'er\'e par le compilateur (dans le cas de KCG, le
code C, par exemple).
\end{itemize}
Notons que le code data-flow est d\'ej\`a un point d'entr\'ee pour les outils
de v\'erification formelle utilis\'es dans le compilateur KCG (le Prover Plug-in). La
v\'erification d'une propri\'et\'e (\'ecrite en Scade) se fait en traduisant le code
et la propri\'et\'e vers le format data-flow qui sert alors de passerelle vers l'outil
Prover.

\subsection{G\'en\'eration de VHDL \`a partir d'\'equations data-flow gard\'ees}
Ce sont principalement les deux approches qui ont \'et\'e retenues dans le
projet GENCOD. La soci\'et\'e GeenSoft a r\'ealis\'e un compilateur \`a partir
du code C g\'en\'er\'e par KCG. Dans ce document, nous d\'ecrivons l'autre
approche dite ``directe'' \`a partir du code interm\'ediaire data-flow
vers un sous-ensemble ``synth\'etisable'' de VHDL (nous reviendrons plus loin
sur ce qualificatif). L'objectif est ici de d\'efinir les fonctions de traduction
le plus formellement possible afin de pouvoir les int\'egrer \`a un environnement certifi\'e
tel que SCADE.

\subsubsection{Un mot sur la traduction de C vers VHDL}
La compilation de SCADE est modulaire: un noeud \texttt{counter}
est traduit vers deux fonctions
C dont l'interface est sch\'ematiquement:

\begin{verbatim}
/* counter.c */
int counter_step(int Counter_res, int Counter_tick,
    counter_mem* self) { ... }

counter_init(counter_mem* self)
  { self->counter_t1 = 0;
    self->counter_t2 = 0; }
)
\end{verbatim}
o\`u:
\begin{verbatim}
typedef struct { 
  int counter_t1; 
  int counter_t2; }
counter_mem;
\end{verbatim}
\texttt{counter\_step} est la fonction de transition qui prend
en entr\'ee un argument suppl\'ementaire repr\'esentant son \'etat interne. L'ex\'ecution
d'un pas produit une sortie et met \`a jour l'\'etat interne (par effet de bord).
La fonction \texttt{counter\_init} permet d'initialiser l'\'etat interne.

Le corps de ces deux fonctions est form\'e d'affectations de variables
locales o\`u de l'\'etat (ici \texttt{self}) ainsi que de structures de contr\^ole
(conditionnelles, construction ``switch'' et boucles ``for'' o\`u
d'appel \`a d'autres fonctions de transition). La
g\'en\'eration de code VHDL suit le sch\'ema suivant:
\begin{itemize}
\item
Une affectation de variable locale
est traduite par une \'equation VHDL sur une variable locale. E.g.,
\texttt{$x$ = $e$} est traduit sch\'ematiquement en une equation VHDL \texttt{$x$ := $e$}.
Il faut cependant \^etre tr\`es attentif \`a ce que \verb-x- ne g\'en\`ere pas de registre.
Ce point est assez d\'elicat puisque, en particulier lors de la traduction de
\texttt{if $cond$ \{ $x$ = $exp$; \}}. Il correspond \`a la d\'efinition d'un flot
dont l'horloge est $cond$. Parce que sa d\'efinition est partielle (la valeur de
$x$ est ind\'efinie lorsque $cond$ est faux, sa traduction en VHDL va conduire le
synth\'etiseur \`a allouer un registre pour $x$, ce qui est \`a la fois inutile et inefficace.
Dans le cas o\`u le programme en entr\'ee n'a pas d'effets de bord, la s\'emantique de
SCADE garantit que ce programme est \'equivalent \`a l'affectation simple $x$ = $exp$.
\item
Une affectation de variable d'\'etat \texttt{$self$ -> $t$ = $exp$} devra, elle,
g\'en\'erer un registre. Il faut cependant retrouver la condition bool\'eenne d'activation
de cette \'equations.
\end{itemize}
L'int\'er\^et d'une traduction du code C produit par KCG vers VHDL est
d'abord de ne pas toucher au compilateur existant (d\'ej\`a qualifi\'e). Nous voyons
cependant plusieurs difficult\'es dans cette approche:
\begin{itemize}
\item
La n\'ecessit\'e de certification demande d'instrumenter
le compilateur KCG avec des informations donnant la tra\c{c}abilit\'e (lien
entre les noms de variables produites et les noms dans le code source,
en particulier).
\item
Certaines optimisations pertinentes lorsque l'on g\'en\`ere du
code s\'equentiel, peuvent ne pas \^etre utiles, voire p\'enalisantes, pour une compilation
vers VHDL. C'est le cas de l'optimisation des structures de contr\^ole
ou de la compilation des boucles (cf. discussion ci-dessus, conduisant \`a g\'en\'erer
trop de registres).
\item
Il est n\'ecessaire de restreindre le p\'erim\`etre du compilateur C vers VHDL: on
ne r\'ealise pas un compilateur capable de traduire tout code C vers VHDL mais
plut\^ot un compilateur adapt\'e au code C produit par KCG et prenant en compte
la technique de compilation sous-jacente. Comment d\'ecrire ce p\'erim\`etre ?
\item
Enfin, c'est une approche assez peu naturelle puisqu'elle
consiste \`a compiler un langage parall\`ele (SCADE) vers un autre langage parall\`ele
(VHDL) en passant par un langage s\'equentiel. D'o\`u la proposition d'une compilation
compilation appliqu\'ee directement au code data-flow interm\'ediaire produit par
KCG.


. Bien qu'il n'existe
pas de d\'efinition pr\'ecise de ce sous-ensemble, nous avons identifi\'e un sous-ensemble
appel\'e MiniVHDL (Section~\ref{section-mini-vhdl}).  dans la litt\'erature, nous
avons identifi\'e unles divers \'echanges
avec les partenaires du projet nous ont cont du Il est apparu au cours du projet qu'il
n'existait pas de d\'efinition pr\'ecise d'un sous-ensemble synth\'etisable
de VHDL. Apr\`es \'echange avec les partenaires, nous avons identifi\'e un
sous-ensemb. Le contexte du projet GENCOD \'etant la g\'en\'eration de code
L'objectif \'etait de proposer avec l'objectif de produire du code
``synth\'etisable''.L'une des difficult\'e a \'et\'e d'identifier un
sous-ensemble de VHDL ``synth\'etisable''.Plusieurs difficult\'es sont
apparues, notamment l'ambiguit\'e de l'expression ``VHDL
synth\'etisable''dL'objectif est de propoduire du code et les r\'esultats
obtenus sont les suivants:

Le code VHDL est obtenu \`a partir du code Le A la diff\'erence de la solution propos\'ee par GeenSoft o\`u la g\'en\'eration de
code VHDL est obtenue \`a partir du code C g\'en\'er\'e par le compilateur KCG de
SCADEA6. Ce prototypune technique de traduction de programmes synchronespr\'esente une m\'ethode de traduction pr\'esente une approche 
On d\'etaille ici la traduction de \LANG{}, un langage synchrone combinant des
\'equations \`a flots de donn\'ees, dans l'esprit de Lustre, et des automates
hi\'erarchiques, tels qu'introduits par Lucid Synchrone et SCADE 6, vers le
langage de description de circuits VHDL. Cette traduction prend le parti de ne
pas passer par un langage imp\'eratif mais de directement utiliser la
repr\'esentation interne \`a flots de donn\'ees du compilateur.

Apr\`es avoir rappell\'e bri\`evement la forme des langages d'entr\'ee et de sortie, on
va expliciter la proc\'edure de traduction retenue.

\section{\LANG{}}

\LANG{} est un langage synchrone acad\'emique conceptuellement proche de SCADE,
mais un peu moins expressif : pas de signaux, peu de constructions riches
(\'emissions sur transitions, etc.). Par rapport aux it\'erations pr\'ec\'edente, il
dispose d\'esormais de tableaux de taille statique et des it\'erateurs associ\'es.

On va d\'ecrire rapidement quelques exemples illustrant les fonctionnalit\'es du
langage, avant de d\'etailler le processus de compilation et l'architecture du
compilateur.

\subsection{Quelques exemples}

\paragraph{Compteur d'\'ev\'enements simple}

\verbatiminput{simpcount.ept}

Le nœud \textit{count} compte le nombre d'\'ev\`enements \textit{e} re\c{c}us depuis le
premier instant du programme.

\paragraph{Compteur multi-\'ev\'enements r\'einitialisable}

\begin{center}
  \verbatiminput{compteur.ept}
\end{center}

Ce programme implante un compteur d'\'ev\'enements qui comptabilise le nombre de
bool\'eens valant \texttt{true} sur son entr\'ee \textit{event}. On utilise les
it\'erateurs \texttt{map} et \texttt{fold} pour calculer le nombre d'\'ev\'enements
observ\'es dans l'instant ; le premier permet de traduire les bool\'eens en entiers,
et le second d'additioner ceux-ci. Notons \'egalement l'utilisation de la
construction de r\'einitialisation \texttt{reset}, actionn\'ee simplement lorsque
l'entr\'ee \textit{rst}\footnote{On suppose que le nom \textit{rst} est frais} est
vraie.

\paragraph{Allocateur de ressource}

\verbatiminput{alloc.ept}

Cet exemple pr\'esente un automate r\'ealisant l'allocation d'une ressource
quelconque \`a deux demandeurs, avec priorit\'e \textit{round-robin} (en cas de
demande simultann\'ee, le processus qui vera sa requ\^etre satisfaite sera celui
ayant obtenu la ressource il y a le plus longtemps).

\subsection{Architecture du compilateur}

On d\'ecrit bri\`evement l'architecture du compilateur : apr\`es des phases initiales
d'analyse lexicale, syntaxique et de typage, le programme \LANG{} est soumis aux
v\'erifications traditionnelles des langages synchrones (causalit\'e,
etc.). Ensuite, on le d\'epouille progressivement de ses constructions de haut
niveau par des r\'e\'ecritures successives, jusqu'\`a arriver \`a une forme simple qui
peut \^etre traduite simplement en MiniLS. Le code r\'esultant, apr\`es avoir \'et\'e
soumis \`a d'\'eventuelles optimisations, est mis dans une certaine forme dite
``normale'' et ordonnanc\'e avant d'\^etre finalement traduit en code
s\'equentiel. L'architecture du compilateur \LANG{} est pr\'esent\'e \`a la figure
\ref{fig:archi}.

% Le compilateur est structur\'e en plusieurs passes effectuant une combinaison
% d'analyses et de transformations, g\'en\'eralement dans le but d'obtenir un code
% imp\'eratif bas-niveau compilable avec les outils idoines. On d\'etaille bri\`evement
% ces diff\'erentes passes, d'abord dans le cas de la compilation traditionnelle
% (cercles verts du sch\'ema) vers un langage imp\'eratif, puis lorsque la cible est
% VHDL (cercles bleus). Les \'etapes quatre \`a sept sont d\'ecrites dans l'article
% \cite{lucy:lctes08a}.

\begin{figure}[htp]
  \centering
  \includegraphics[scale=0.5]{archi}
  \caption{Architecture du compilateur \LANG{}}
  \label{fig:archi}
\end{figure}

Le passage au code s\'equentiel est court-circuit\'e lors d'une compilation vers
VHDL, qui traduit MiniLS directement vers celui-ci. Pour faciliter cette \'etape,
on pratiquera en amont trois transformations simplificatrices sur MiniLS.

\renewcommand{\labelenumi}{\Alph{enumi}}
\begin{enumerate}
\item Suppression de la r\'einitialisation logique.
\item Suppression des it\'erateurs sur tableaux via mise \`a plat.
\item Introduction d'une variable interm\'ediaire pour chaque argument d'un appel
  de noeud.
\item Traduction vers un sous ensemble de VHDL baptis\'e MiniVHDL.
\end{enumerate}

Le code MiniVHDL obtenu peut ensuite \^etre trait\'e par les outil d\'edi\'es.

\section{De \LANG{} \`a VHDL}

\subsubsection{Syntaxes}

\TODO{Donner la forme originale sans reset telle qu'avant normalisation ?}

\paragraph{MiniLS}
\label{sec:syn:mls}

\begin{figure}[h]
  \centering
  \begin{eqnarray*}
    td & \Coloneqq & \mybox{type } bt = C + \dots + C \\
    d & \Coloneqq & \Node{p}{p}{p}{D} \\
    p & \Coloneqq & x : bt; \dots; x : bt \\
    D & \Coloneqq & pat = e; \dots; pat = e \\
    pat & \Coloneqq & x \p (pat,\dots,pat) \\
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \Fby{v}{e} \p \Pre{e} \\
    & \p & \Every{f}{e}{e}{x} \p \When{e}{C}{x} \\
    & \p & \Merge{x}{C}{e}{C}{e} \\
    & \p & \Map{f}{e_1}{e_n} \\
    & \p & \Fold{f}{e_1}{e_n} \\
    & \p & \Mapfold{f}{e_1}{e_n} \\
    v & \Coloneqq & i \p C \\
    ck & \Coloneqq & \Base \p \On{ck}{C}{x}
  \end{eqnarray*}
  \caption{MiniLS}
  \label{fig:mls}
\end{figure}

MiniLS est \'equivalent au langage synchrone \`a flots de donn\'ees bien connu qu'est
Lustre \cite{lustre}, auquel on adjoint une construction de r\'einitialisation
modulaire d'un noeud\footnote{$\Every{f}{e_1}{e_n}{z}$ appelle le noeud $f$ avec
  les arguments $e_1,\dots,e_n$, et r\'einitialise la m\'emoire de celui-ci lorsque
  $z$ est vraie.}.

Les programmes MiniLS sont pr\'esents dans le compilateur sous trois formes
distinctes ; la premi\`ere est donn\'ee par souci de coh\'erence et ne nous int\'eresse
pas directement, les pr\'ec\'edentes passes du compilateur nous fournissant
directement la deuxi\`eme. Ce processus de compilation est d\'ecrit en d\'etails dans
l'article \cite{lctes08a}.

\begin{itemize}
\item Forme originale \ref{fig:mls} telle qu'obtenue \`a partir du code \LANG{}
  original.
\item Forme normale \ref{fig:mlsn}.
\item Forme finale \ref{fig:mlsns}, normalis\'ee, sans r\'einitialisations ($every$)
  ni it\'erateurs, et o\`u tous les param\`etres effectifs sont des noms
  d'identifiants.
\end{itemize}

On va d\'ecrire les constructions du langage :

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \When{e}{C}{x} \\
    ce & \Coloneqq & e \p \Merge{x}{C}{ce}{C}{ce} \\
    eq & \Coloneqq & x = ce \p x = \Fby{v}{e} \p x = \Pre{e} \\
    & \p & (x,\dots,x) = \Every{f}{e}{e}{x} \\
    & \p & (x,\dots,x) = \App{f}{e,\dots,e} \\
    & \p & \Map{f}{e_1}{e_n} \\
    & \p & \Fold{f}{e_1}{e_n} \\
    & \p & \Mapfold{f}{e_1}{e_n}
  \end{eqnarray*}
  \caption{MiniLS normalis\'e}
  \label{fig:mlsn}
\end{figure}

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    e & \Coloneqq & x \p v \p \Op{e}{e} \p \When{e}{C}{x} \\
    ce & \Coloneqq & e \p \Merge{x}{C}{ce}{C}{ce} \\
    eq & \Coloneqq & x = \Pre{e} \\
    & \p & (x,\dots,x) = \App{f}{x,\dots,x}
  \end{eqnarray*}
  \caption{MiniLS simplifi\'e (et normalis\'e)}
  \label{fig:mlsns}
\end{figure}

\paragraph{MiniVHDL}

MiniVHDL \ref{fig:mvhdl} est un fragment tr\`es restreint de VHDL, suffisant pour
d\'ecrire l'essence de notre processus de traduction. Un composant MiniVHDL
$\Component{f}{P}{sigs}{lvars}{ports}{I}$ correspondra concr\`etement \`a un
composant VHDL form\'e des instantiations $ports$, signaux internes $sigs$ et d'un
processus avec les variables locales $lvars$ et de corps $I$.

Notons que les param\`etres effectifs des instantiations de composants sont des
noms de signaux ; cela justifie la forme simplifi\'ee MiniLS d\'ecrite au paragraphe
pr\'ec\'edent.

\begin{figure}[htp]
  \centering
  \begin{eqnarray*}
    component & \Coloneqq & \mybox{component} \; f \; \mybox{port} \; sm;\dots;\
    sm \; \mybox{with} \, \mybox{sig} \; d; \dots; d \; \\
    & & \mybox{and} \, \mybox{var} \; d; \dots; d \; \mybox{and} \
    \mybox{subcomponents} \; p; \dots; p \; \mybox{in} \; I \\
    sm & \Coloneqq & x : mode \ ty \\
    sd & \Coloneqq & x : mode \ ty \coloneqq e \\
    mode & \Coloneqq & \mybox{in} \p \mybox{out} \\
    d & \Coloneqq & x : ty \\
    p & \Coloneqq & \mybox{port map } x (bd;\dots;bd) \\
    bd & \Coloneqq & x \Rightarrow x \\
    I & \coloneqq & i; \dots; i \\
    i & \Coloneqq & \Assign{x}{e} \p \Affect{x}{e} \p \Case{e}{v}{I}{v}{I} \\
    e & \Coloneqq & id \; \vert \; v \; \vert \; \Op{e}{e} \\
    v & \Coloneqq & i \; \vert \; ' bitp ' \\
    bitp & \Coloneqq & bit \p bit \  bitp \\
    bit & \Coloneqq & \mathbf{0} \p \mathbf{1} \\
    bt & \Coloneqq & \mybox{natural} \p \mybox{std\_logic} \p \mybox{bit}
    \p \dots
  \end{eqnarray*}
  \caption{MiniVHDL}
  \label{fig:mvhdl}
\end{figure}

% On y ajoute comme raccourci syntaxique l'instruction suivante : $$\mybox{if } e
% \mybox{ then } I \mybox{ else } J \equiv \mybox{case } e \mybox{ of } ('1'
% \Rightarrow I) ('0' \Rightarrow J)$$

\subsubsection{Simplification de MiniLS normalis\'e}

Nous effectuons donc trois passes pour simplifier le code MiniLS.

\paragraph{\'Elimination de la r\'einitialisation logique}

Certaines constructions de MiniLS proposent au programmeur une forme de
r\'einitialisation modulaire : les \'equations de la forme $\Fby{v}{e}$ d'un noeud
$f$ instanci\'e par la construction $\Every{f}{e_1}{e_n}{z}$ doivent-\^etre
r\'einitialis\'ees d\`es lors que $z$ est vrai.

La premi\`ere passe de simplification, qui s'ex\'ecute sur le code MiniLS obtenu \`a
la troisi\`eme \'etape du processus d\'ecrit plus haut, permet d'\'eliminer ces
constructions $every$ dans le but de compiler plus uniform\'ement vers VHDL,
autrement dit sans n\'ecessiter un traitement ad-hoc de la r\'einitialisation.

L'id\'ee est d'ajouter \`a chaque noeud un argument suppl\'ementaire nomm\'e
\textit{rst} correspondant \`a un appel n\'ecessitant une r\'einitialisation de la
m\'emoire. La passe se charge de modifier les appels de noeuds pour synth\'etiser
l'expression correcte, en particulier dans le cas d'une \'equation de type $(x_1,
\dots, x_n) = \Every{f}{e}{e}{x}$ o\`u $x$ doit \^etre capable de r\'einitialiser
$f$. Les m\'emoires r\'einitialisables $\Fby{v}{e}$ doivent bien-entendu \^etre
r\'einitialis\'ees lorsque l'argument \texttt{rst} est vrai ; pour cela, il suffit
de remplacer ces derni\`eres par $\If{rst}{v}{\newline \Pre{e}}$.

Les fonctions suivantes effectuent ces deux t\^aches : $RstE$ traite une
expression MiniLS, et $RstNode$ ajoute l'argument \texttt{rst} \`a un noeud et
transforme ses \'equations.

\newcommand{\re}[1]{RstE(#1)}
\newcommand{\rstn}[1]{RstNode(#1)}

\[
\begin{array}{lcl}
  \re{\Op{e_1}{e_n}} & = & \Op{\re{e_1}}{\re{e_n}} \\
  \re{\Fby{v}{e}} & = & \If{rst}{v}{\Fby{v}{\re{e}}} \\
  \re{\Pre{e}} & = & \Pre{\re{e}} \\
  \re{\Every{f}{e_1}{e_n}{x}} & = & \App{f}{\mathtt{rst} \; \mathbf{or} \;
    x, \re{e_1} \dots, \re{e_n}} \\
  \re{\App{f}{e_1,\dots,e_n}} & = &
  \App{f}{\mathtt{rst},\re{e_1},\dots,\re{e_n}} \\
  \re{\If{e_1}{e_2}{e_3}} & = & \If{\re{e_1}}{\re{e_2}\\ & & \hspace{1.7cm}}
  {\re{e_3}} \\
  \re{\When{e}{C}{x}} & = & \When{\re{e}}{C}{x} \\
  \re{\Merge{e}{C_1}{e_1}{C_n}{e_n}} & = &
  \mybox{merge} \; \re{e} \; (C_1 \Rightarrow \re{e_1}) \\
  & & \hspace{2.2cm} \dots \\
  & & \hspace{2.2cm} (C_n \Rightarrow \re{e_n})
\end{array}
\]

\[
\begin{array}{ll}
  RstEqs(pat_1 = e_1;\dots;pat_n = e_n) & = \\
  \ind pat_1 = \re{e_1};\dots;pat_n = \re{e_n} \\
  \rstn{\Node{f}{x_1,\dots,x_n}{y_1,\dots,y_n}{eqs}} & = \\
  \ind \Node{f}{rst,x_1,\dots,x_n}{y_1,\dots,y_n}{ResetEqs(eqs)}
\end{array}
\]

\paragraph{Suppression des it\'erateurs}

La version actuelle du compilateur et de son g\'en\'erateur de code VHDL supporte
les tableaux de dimension arbitraire \footnote{En pratique, les outils de
  synth\`ese de circuits \`a partir de code VHDL imposent une dimension maximale.}
et constructions associ\'ees ; il nous faut donc compiler les it\'erateurs
\texttt{map}, \texttt{fold} et \texttt{mapfold} vers VHDL.

Par souci de simplicit\'e et uniformit\'e, nous avons fait le choix de les \'eliminer
par \textit{inlining} lors d'une transformation source-\`a-source sur MiniLS. On
ne d\'etaillera pas cette op\'eration qui consiste simplement \`a remplacer les
it\'erateurs par plusieurs \'equations. L'\'equation $x = \Map{f}{t_1}{t_m}$ lorsque
les tableaux $t_1, \dots, t_m$ sont de taille $n$ sera ainsi remplac\'ee par $n +
1$ \'equations dont les $n$ premi\`eres effectuent l'application de $f$ pour chaque
indice et la derni\`ere affecte \`a $x$ le tableau en r\'esultant. On applique des
transformations similaires aux op\'erateurs \texttt{fold} et \texttt{mapfold}.

Le programme suivant pr\'esente un exemple effectuant un ET logique sur tous les
\'el\'ements d'un tableau via l'it\'erateur \texttt{fold}.

\verbatiminput{fold_orig.ept}

Son pendant avec it\'erateur mis \`a plat se contente de passer l'accumulateur
d'\'el\'ement en \'el\'ement.

\verbatiminput{fold_il.ept}

\paragraph{Simplification des appels}

Comme nous le verrons plus bas, les appels de nœuds seront compil\'es en
instantiations de composants ; or, les arguments d'une construction VHDL $port
\; map$ sont forc\'ement des identifiants. Autant se simplifier la t\^ache en amont
: on va donc transformer tout appel de noeud en introduisant une variable
interm\'ediaire pour chaque argument.

\newcommand{\simpl}[2]{Simpl(#1,#2)}
\newcommand{\simplnd}[1]{SimplNode(#1)}

\[
\begin{array}{ll}
  \simpl{x = ce}{eqs} & = \\
  \ind (x = ce) \Cons eqs \\
  \simpl{x = \Pre{e}}{eqs} & = \\
  \ind (x = \Pre{e}) \Cons eqs \\

  \simpl{(x_1,\dots,x_n) = \App{f}{e_1,\dots,e_n}}{eqs} & = \\
  \ind (y_1 = e_1) \Cons \dots \Cons (y_n = e_n)
  \Cons ((x_1,\dots,x_n) = \App{f}{rst,y_1,\dots,y_n}) \Cons eqs \\
  \ind \mbox{o\`u } y_1,\dots,y_n \mbox{ sont des noms de variables frais}
\end{array}
\]

\[
\begin{array}{ll}
  \simplnd{\Node{x_1,\dots,x_n}{y_1,\dots,y_n}{p}{D}} & = \\
  \ind \mathtt{node} f(x_1,\dots,x_n) = y_1, \dots, y_n \; \\
  \ind \mathtt{with} \  \mathtt{var} \; p' \; \mathtt{in} \; fold\_right \;Simpl
  \; D \; [] \\
  \ind \mbox{en supposant que que } p' \mbox{ correspond} \\
  \ind \mbox{aux variables d\'efinies par les nouvelles \'equations.}
\end{array}
\]

Ces simplifications effectu\'ees, on va s'atteler \`a la traduction de MiniLS vers
MiniVHDL.

\subsubsection{MiniLS simplif\'e vers MiniVHDL}

Les id\'ees g\'en\'erales de la traduction de MiniLS simplifi\'e vers MiniVHDL sont les
suivantes :

\begin{itemize}
\item Chaque noeud MiniLS correspondra \`a un composant (Mini)VHDL.
\item Chaque \'equation \`a m\'emoire (i.e. contenant $fby$ ou $pre$) va correspondre
  \`a un signal, chaque \'equation combinatoire \`a une variable locale.
\item La r\'einitialisation logique est g\'er\'ee en amont comme expliqu\'ee ci-dessus,
  elle est donc implicitement asynchrone (ind\'ependante des fronts montants de
  l'horloge).
\item Les partenaires ont exprim\'e le d\'esir de pouvoir r\'einitialiser physiquement
  toute la m\'emoire lors du bascument d'un signal pr\'ecis nomm\'e
  \textit{hwrst}\footnote{Tout comme \textit{rst}, \textit{hwrst} est frais.} :
  on ajoute donc ce signal suppl\'ementaire invisible dans le code MiniLS et on
  g\'en\`ere le code de r\'einitialisation correspondant lors du traitement du $fby$.
\item Pour respecter la s\'emantique \`a $\Delta$-cycles de VHDL, il importe de
  faire \'evoluer la m\'emoire par un pas du calcul uniquement sur front montant de
  l'horloge.
\item En suivant le mod\`ele synchrone, les valeurs calcul\'ees par le circuit \`a
  d'autres moments que le front montant n'ont pas de sens bien d\'efini ; on les
  ignorera donc.
\item Chaque appel de noeud correspondra \`a une instantiation. Comme sp\'ecifi\'e
  plus haut, les param\`etres effectifs d'un signal VHDL sont obligatoirement des
  signaux auxquels il faudra assigner la valeur correcte.
\end{itemize}

\paragraph{Traduction des types}

Les d\'eclarations de types de donn\'ees ont \'et\'e laiss\'ees implicites aussi bien dans
la syntaxe de MiniLS que de MiniVHDL ; les possibilit\'es \'etant exactement les
m\^emes (\'enum\'erations et enregistrements), on choisit de ne pas s'attarder sur
leur traduction qui reste une traduction mot-\`a-mot d'une syntaxe concr\`ete \`a
l'autre.

\paragraph{Traduction des constantes et fonction auxiliaires sur les horloges}

La fonction $TradConst$ traduit une constante MiniLS en constante MiniVHDL.

\newcommand{\TradC}[1]{TradConst(#1)}

\[
\begin{array}{lcl}
  \TradC{i} & = & i \\
  \TradC{true} & = & '1' \\
  \TradC{false} & = & '0' \\
  \TradC{C} & = & C
\end{array}
\]

La fonction auxiliaire $GuardClock$ permet de traduire une horloge MiniLS en
expression MiniVHDL de type bool\'een. Elle sera utilis\'ee pour contr\^oler la mise \`a
jour des registres, s'assurant que cette derni\`ere n'est effectu\'ee qu'aux
instants o\`u l'horloge est effective.

\newcommand{\GEC}[1]{GuardClock(#1)}

\[
\begin{array}{lcl}
  \GEC{\Base} & = & rising\_edge(clk) \\
  \GEC{\On{ck}{C}{x}} & = & x = \TradC{C} \; \mathtt{and} \; \GEC{ck}
\end{array}
\]

Tout comme les mises \`a jour des m\'emoires, les appels \`a d'autres noeuds sont
dirig\'es par les horloges qui en donnent la cadence. Il nous faudra donc une
fonction voisine de $GuardClock$ pour calculer l'expression MiniVHDL
correspondant \`a l'horloge utilis\'ee dans l'appel d'un noeud.

\newcommand{\EC}[1]{ExpClock(#1)}

\[
\begin{array}{lcl}
  \EC{\Base} & = & clk \\
  \EC{\On{ck}{C}{x}} & = & x = \TradC{C} \; \mathtt{and} \; \EC{ck}
\end{array}
\]

\paragraph{Traduction des expressions et \'equations}

La fonction $TradExp$ traduit les expressions simples MiniLS normalis\'es et
simplifi\'e en expressions MiniVHDL.

\newcommand{\TradE}[1]{TradExp(#1)}

\[
\begin{array}{lcl}
  \TradE{v} & = & \TradC{v} \\
  \TradE{x} & = & x \\
  \TradE{\Op{e_1}{e_n}} & = & \Op{\TradE{e_1}}{\TradE{e_n}} \\
  \TradE{\When{e}{C}{x}} & = & \TradE{e}
\end{array}
\]

La fonction $TradCExp$ traduit les expressions de contr\^ole form\'ees d'expressions
simples ou de \texttt{merge} imbriqu\'es en instructions MiniVHDL.

\newcommand{\TradCE}[2]{TradCExp(#1, #2)}

\[
\begin{array}{ll}
  \TradCE{x}{\Merge{y}{C_1}{ce_1}{C_n}{ce_n}} & = \\
  \ind \mathtt{case} \; y \; \mathtt{of} \;
  (\TradC{C_1} \Rightarrow \TradCE{x}{ce_1}) \\
  \hspace{2.1cm} \dots \\
  \hspace{2.1cm} (\TradC{C_n} \Rightarrow \TradCE{x}{ce_n}) \\
  \TradCE{x}{e} & = \\
  \ind \Affect{x}{\TradE{e}}
\end{array}
\]

Enfin, la fonction $TradEq$ permet de passer des \'equations aux instructions
MiniVHDL. Elle prend un argument suppl\'ementaire permettant de compter le nombre
d'appels de noeuds afin de g\'en\'erer des arguments suppl\'ementaires, et on se donne
une fonction suppl\'ementaire $MakeArg(x,i)$ qui g\'en\`ere un nom de variable frais \`a
partir du nom de variable $x$ et de l'entier $i$.

La traduction des \'equations appelant un noeud n\'ecessite des explications
concernant la fa\c{c}on de compiler les appels d'un noeud MiniLS qui seront donn\'ees
\`a la section suivante.

\newcommand{\TradEq}[2]{TradEq(#1,#2)}
\newcommand{\MA}[2]{MakeArg(#1,#2)}

\[
\begin{array}{lcl}
  \TradEq{x = ce}{i} & = & \TradCE{x}{ce}, i \\

  \TradEq{x = \Pre{e}}{i} & = & \mathtt{if} \; \GEC{ck} \; \mathtt{then} \\
  & & \ind \Assign{x}{\TradE{e}} \\
  & & \mathtt{end} \; \mathtt{if}, i \\

  \TradEq{x = \Fby{y}{e}}{i} & = & \mathtt{if} \; \mathbf{hwrst}
  \; \mathtt{then} \\
  & & \ind \Assign{x}{y} \\
  & & \mathtt{elsif} \; \GEC{ck} \; \mathtt{then} \\
  & & \ind \Assign{x}{\TradE{e}} \\
  & & \mathtt{end} \; \mathtt{if}, i \\


  \TradEq{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}}{n} & = &
  \Assign{\MA{"ck"}{i}}{\EC{ck}} \\
  & & \Assign{\MA{y_1}{i}}{y_1} \\
  & & \dots \\
  & & \Assign{\MA{y_n}{i}}{y_n}, i + 1 \\
\end{array}
\]

Pr\'ecisons que par construction, l'interface d'un composant est toujours de la
forme $(clk, in_1, \dots,in_n, out_1,\dots,out_n)$.

\paragraph{Gestion des tableaux}

Hormis le cas des it\'erateurs trait\'es pr\'ec\'edemment, la gestion des tableaux
n'appelle pas de commentaire particulier, \`a l'exception de l'anecdotique mais
g\^enante n\'ecessit\'e de d\'eclarer \`a l'avance les types tableaux (bornes exclues) en
VHDL. Deux solutions sont envisageables :

\begin{itemize}
\item Calculer la dimension maximale des tableaux rencontr\'es dans le programme,
  et utiliser cette information pour pr\'e-d\'eclarer les tableaux VHDL idoines.
\item D\'eclarer quoi qu'il advienne les types de tableaux utiles et refuser les
  programmes comprenant des dimensions sup\'erieures \`a une limite fix\'ee \`a l'avance
  .
\end{itemize}

Le compilateur emploie pour l'instant la premi\`ere m\'ethode, mais la seconde ne
nous semble pas d\'erangeante pour des raisons pragmatiques\footnote{Notons que
  notre version de l'outil Xilinx ISE refuse par exemple tout tableau de
  dimension sup\'erieure \`a trois.}.

\paragraph{Compilation modulaire et appels de noeuds}

MiniVHDL offre une forme de modularit\'e bas\'ee sur une hi\'erarchie de
composants. Chacun de ces derniers sp\'ecifie une liste de composants fils dont
les ports (au sens de la figure \ref{fig:mvhdl}) sont instanci\'es avec des
signaux. Nous prenons donc soin d'utiliser des signaux comme r\'esultats mais
aussi arguments ; par souci de simplicit\'e, on introduit des signaux locaux pour
chaque argument, signaux qui seront affect\'es lors de la traduction de l'\'equation
correspondant \`a l'appel de noeud original.

La fonction $GatherPortMaps(D, i)$ rassemble cette liste de sous-noeuds \`a partir
des appels de noeud pr\'esents dans le paquet d'\'equations $D$ et cr\'e\'e les
instantiations de composants correspondantes. L'entier $i$ nous servira \`a
distinguer les appels de noeuds et de cr\'eer de nouveaux noms de signaux frais
gr\^ace \`a la fonction $MakeArg$ d\'ecrite plus haut. On se donne \'egalement une
fonction $GetArgName(f,n)$ qui renvoie le nom du $n$-\`eme argument du noeud de
nom $f$.

\newcommand{\GPM}[2]{GatherPortMaps(#1,#2)}
\newcommand{\GAN}[2]{GetArgName(#1,#2)}

\[
\begin{array}{lcl}
  \GPM{[]}{i} & = & [] \\
  \GPM{((x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}) \Cons eqs}{i} & = &
  \\
  \ind \mybox{port map} \; f ( clk \Rightarrow \MA{"clk"}{i} \\
  \ind \ind \ind \ind \hspace{0.4cm} \GAN{f}{1} \Rightarrow \MA{y_1}{i} \\
  \ind \ind \ind \ind \hspace{0.4cm} \dots \\
  \ind \ind \ind \ind \hspace{0.4cm} \GAN{f}{n} \Rightarrow \MA{y_n}{i}) \\
  \ind \Cons \GPM{eqs}{i + 1}
\end{array}
\]

On d\'efinit ensuite les fonctions auxiliaires $NeedVar$, $Vars$, $ParamSigs$ et
$SignalOfVarDec$ respectivement charg\'ees de d\'eterminer si une \'equation introduit
des d\'eclarations de variables locales ou non, de calculer la liste des variables
d\'efinies par une \'equation, de calculer les signaux \`a passer en arguments aux
appels de noeuds pr\'esents dans un paquet d'\'equations et enfin de traduire
simplement une d\'eclaration de variable MiniLS en d\'eclaration de signal MiniVHDL
avec mode d'utilisation (entr\'ee ou sortie).

\newcommand{\NV}[1]{NeedVar(#1)}
\newcommand{\V}[1]{Vars(#1)}
\newcommand{\PS}[2]{ParamSigs(#1,#2)}
\newcommand{\SoVD}[3]{SignalOfVarDec(#1 : #2, #3)}

\[
\begin{array}{lcl}
  \NV{x = \Fby{v}{e}} & = & false \\
  \NV{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}} & = & false \\
  \NV{x = ce} & = & true
\end{array}
\]

\[
\begin{array}{lcl}
  \V{x = \Fby{v}{e}} & = & [x] \\
  \V{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n}} & = & x_1 \Cons \dots \Cons x_n \\
  \V{x = ce} & = & [x]
\end{array}
\]

\[
\begin{array}{ll}
  \PS{x = \Fby{v}{e} \Cons eqs}{i} & = \\
  \ind \PS{eqs}{i} \\
  \PS{(x_1,\dots,x_n) = \App{f}{y_1,\dots,y_n} \Cons eqs}{i} & = \\
  \ind \MA{"clk"}{i} \Cons \MA{y_1}{i} \Cons \dots \Cons \MA{y_n}{i} \\
  \ind \mathtt{::} \; \PS{eqs}{i + 1}
  \\
  \PS{x = ce \Cons eqs}{i} & = \\
  \ind \PS{eqs}{i}
\end{array}
\]

\[
\begin{array}[lcl]{lcl}
  \SoVD{x}{bt}{mode} & = & \mybox{signal} \; x : mode \; TransBaseType(bt)
\end{array}
\]

\paragraph{Traduction des noeuds}

Enfin, $TradNode$ se charge de traduire un noeud en composant MiniVHDL, en
cr\'eant un signal local pour chaque \'equation retard\'ee et argument d'appel de
noeud, une variable pour chaque \'equation combinatoire, et la liste de
sous-composants requise.

\begin{align*}
  & TradNode(\mybox{node } f(in) = out \mybox{ with var } p \mybox{ in } D) = \\
  & \bl \mbox{soit } port = \\
  & \bl \bl clk : \mybox{in std\_logic}; \\
  & \bl \bl \{ SignalOfVarDec(x : bt, \mybox{in}) \p (x : bt) \in in \}; \\
  & \bl \bl \{ SignalOfVarDec(x : bt, \mybox{out}) \p (x : bt) \in out \}, \\
  & \bl \mbox{ soit } signals = \{ \V{eq} \p eq \in D, \neg \NV{eq} \}
  \mybox{,} \\
  & \bl \mbox{ soit } sig\_args = \PS{D}{1} \mybox{,} \\
  & \bl \mbox{ soit } variables = \{ \V{eq} \p eq \in D, \NV{eq} \} \mybox{,} \\
  & \bl \mbox{ soit } ports = \GPM{D}{1} \mybox{,} \\
  & \bl \mbox{ soit } body = fold\_right TradEq D ([], 1) \mbox{ dans} \\
  & \mybox{component } f \mybox{ port } port \mybox{ with sig } signals \cup
  sig\_args \\
  & \mybox{and var } variables \mybox{ and subcomponents } ports \mybox{ in }
  body
\end{align*}

\section{Discussion}

\section{Conclusion}

On a traduit \LANG{} vers VHDL en profitant des forces du mod\`ele synchrone : sa
s\'emantique est bien adapt\'ee \`a une description sous forme de circuits. Le
processus de traduction reste simple et compr\'ehensible gr\^ace aux garanties
offertes par le synchrone : nul besoin d'\'ecrire plusieurs fois dans le m\^eme
\'el\'ement m\'emorisant par cycle.

\tableofcontents


\appendix

\section{Exemples de code g\'en\'er\'e}

On pr\'esente ici quelques codes g\'en\'er\'es par notre prototype. En l'\'etat actuel de
ce dernier, beaucoup de variables interm\'ediaires sont g\'en\'er\'ees ; une passe
d'optimisation puissante est en d\'eveloppement.

On liste successivement le code MiniLS obtenu \`a partir de \LANG{}, puis le code
MiniLS normalis\'e et ordonnanc\'e, et enfin le code VHDL.

\subsection{Compteur}

\paragraph{MiniLS initial}

\small
\verbatiminput{compteur2_init.mls}
\normalsize

\paragraph{MiniLS normalis\'e, ordonnanc\'e et simplifi\'e}

Notons que le noeud \textit{compteur} est ici instanci\'e avec son param\`etre
\textit{n} \'egal \`a 4, ceci afin de pouvoir d\'eplier les it\'erateurs.

\small
\verbatiminput{compteur2_sched.mls}
\normalsize

\paragraph{VHDL}

\small
\verbatiminput{compteur2_vhdl.vhd}
\normalsize

\subsection{Allocateur de ressource}

\paragraph{MiniLS initial}

\small
\verbatiminput{al2_init.mls}
\normalsize

\paragraph{MiniLS normalis\'e, ordonnanc\'e et simplifi\'e}

\small
\verbatiminput{al2_sched.mls}
\normalsize

\paragraph{VHDL}

\small
\verbatiminput{al2_vhdl.vhd}
\normalsize

\section{Utilisation du compilateur}

Nous supposerons dans ce manuel que l'archive du compilateur a \'et\'e d\'ecompress\'ee
dans le r\'epertoire \verb/$HEPTDIR/. Cette archive contient le pr\'esent rapport,
un r\'epertoire \texttt{exs/} avec une batterie d'exemples \LANG{} compil\'es vers
VHDL, et un binaire en code-octet pour la machine abstraite OCaml. Ce dernier
peut-\^etre ex\'ecut\'e via \texttt{ocamlrun heptc}, ou bien directement lorsque votre
\texttt{ocamlrun} est pr\'esent dans \texttt{/usr/bin/}. Nous supposerons par la
suite que c'est le cas et que votre variable d'environnement \verb/$PATH/
contient \verb/$HEPTDIR/bin/.

Pour utiliser le compilateur, il faut tout d'abord renseigner la variable
d'environnement \verb/$HEPTLIB/ sp\'ecifiant au compilateur o\`u trouver la
biblioth\`eque standard.

\begin{verbatim}
$ export HEPTLIB=$HEPTDIR/lib
\end{verbatim}

Vous pouvez ensuite v\'erifier que le compilateur est disponible et fonctionnel
via la commande suivante :

\begin{verbatim}
$ heptc -version
The Heptagon compiler, version 0.4 (wed. aug. 18 11:17:42 CET 2010)
Standard library in [...]
\end{verbatim}

Pour compiler un fichier \LANG{}, le compilateur doit \^etre invoqu\'e avec l'option
\verb/-target/. Les arguments possibles pour cette option sont :

\begin{itemize}
\item \verb/vhdl/ : g\'en\`ere du code VHDL.
\item \verb/mls/ : g\'en\`ere le code \`a flots de donn\'ees MiniLS interm\'ediaire.
\item \verb/obc/ : g\'en\`ere un code imp\'eratif simple dans le langage id\'ealis\'e Obc.
\item \verb/c/ : g\'en\`ere du code C.
\end{itemize}

Les cibles VHDL et C invoqu\'ees sur un fichier \verb/source.ept/ produisent
respectivement un dossier \verb/source_vhdl/ et \verb/source_c/ qui contiennent
les fichiers sources g\'en\'er\'es. Par exemple :

\begin{verbatim}
$ cat source.ept
node main() returns (o : int)
let
  o = 0 fby (o + 1);
tel
$ heptc -target vhdl source.ept
$ ls source_vhdl
main.vhd  types.vhd
\end{verbatim}

L'option \verb/-s noeud/ permet de g\'en\`erer le code n\'ecessaire \`a un ex\'ecutable
autonome \`a partir d'un fichier source \LANG{}, c'est \`a dire un
\textit{test-bench} dans le cas de VHDL et une fonction \verb/main()/ en ce qui
concerne C. Voici un exemple d'utilisation de la sortie C :

\begin{verbatim}
$ cat source.ept
node noeud() returns (o : int)
let
  o = 0 fby (o + 1);
tel

node main() returns (o : int)
let
  o = noeud() + 1;
tel
$ heptc -target c -s main source.ept
$ ls source_c
_main.c  _main.h  source.c  source.h  source_types.c  source_types.h
$ cc -Isource_c source_c/*.c -o source
$ ./source 5 # Option indiquant \`a l'ex\'ecutable g\'en\'er\'e de s'arr\^eter apr\`es 5 pas
=> 1
=> 2
=> 3
=> 4
=> 5
\end{verbatim}

\bibliography{biblio}
\bibliographystyle{plain}

\end{document}
