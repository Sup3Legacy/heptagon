\documentclass{beamer}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{fancyvrb}

\hypersetup{
  backref=true, %permet d'ajouter des liens dans...
  pagebackref=true,%...les bibliographies
  hyperindex=true, %ajoute des liens dans les index
  colorlinks=true, %colorise les liens
  breaklinks=true, %permet le retour a la ligne dans les liens trop longs
  urlcolor=blue,  %couleur des hyperliens (blue pour la version web)
  linkcolor=blue, %couleur des liens internes (blue pour la version web)
  citecolor=blue, %couleur des citation (green pour la version web)
  bookmarks=true,  %cree des signets pour Acrobat
  bookmarksopen=true, %affiche completement les signets Acrobat
  %%%%%%%%%%%%%%%%% HYPER TITLE %%%%%%%%%%%%%%%%%%%%%%%%%%
  pdfsubject={Transparents} %document sous Acrobat.
}

\usetheme{boxes}
% \definecolor{MonJaune}{HTML}{FFCC00}
% \setbeamercolor{block title}{fg=MonJaune}

\include{pygments}

\logo{\includegraphics[height=1cm]{gencod}}
% \logo{\insertframenumber/\inserttotalframenumber}

\newcommand{\FIXME}{\textcolor{red}{FIXME}}
\newcommand{\TODO}[1]{(\textcolor{red}{TODO} #1)}
%\newcommand{\TODO}[1]{}
\newcommand{\LANG}{{\sc Heptagon}}
\newcommand{\lucy}{{\sc Lucid Synchrone}}
\newcommand{\lustre}{{\sc Lustre}}
\newcommand{\scade}{{\sc Scade}}
\newcommand{\scadesix}{{\sc Scade~6}}
\newcommand{\minils}{{\sc MiniLS}}
\newcommand{\heptagon}{{\sc Heptagon}}
\newcommand{\obc}{{\sc Obc}}
\newcommand{\minivhdl}{{\sc MiniVHDL}}
\newcommand{\vhdl}{{\sc Vhdl}}

\title{Revue du projet GenCod}
\author{Adrien Guatto et Marc Pouzet\\
        LRI}
\date{Mardi 5 Octobre 2010}

\begin{document}

% \maketitle

\begin{frame}[t,plain]
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Contexte scientifique}

  \begin{block}{Question soulevée dans le cadre du projet GenCod}
    Générer une description de matériel à partir de programmes écrits en
    \scadesix{}.
  \end{block}

  \begin{block}{Approche retenue}
    \begin{itemize}
    \item Génération modulaire de code VHDL à partir de code data-flow.
    \item Mise en oeuvre dans un prototype (\heptagon{}).
    \end{itemize}
  \end{block}

  \begin{block}{Prototype}
    \begin{itemize}
    \item Un sous-ensemble du langage (académique) \lucy{} (Pouzet et al.).
    \item Traits principaux (data-flow, automates, tableaux) pr\'esents dans
      SCADE 6.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Réalisation}

  \begin{center}
    \includegraphics[scale=0.65]{comparo.pdf}
  \end{center}

  Les traits marquants d'\heptagon{} sont :

  \begin{itemize}
  \item Les programmes sont structurés en noeuds contenants des équations de
    suites ou des automates.
  \item Le processus de compilation vérifie des propriétés de sûreté et raffine
    le programme jusqu'à générer du code impératif (e.g. langage C).
  \item<alert@2-> Il est possible de générer du code VHDL.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Génération de code VHDL}

  \begin{center}
    \includegraphics[scale=0.4]{sens_traduction.pdf}
  \end{center}

  Pour produire du code VHDL, on considère la génération de code depuis un
  langage intermédiaire data-flow ``gardé'' (utilisée dans les langages \lucy{}
  et \scadesix{}).

  La compilation est une suite de réécritures du programme data-flow.

  \begin{itemize}
  \item Chacune est formellement spécifiée et concise.
  \item Chaque étape intermédiaire peut-être vérifiée à posteriori.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Exemple 1 : compteur - code original}

  \input{compteur}
\end{frame}


\begin{frame}
  \frametitle{Exemple 1 : compteur - exemple de sortie attendue}

  \[
  \begin{array}{r|llllllllllllllllllllllllllll}
    \hline
    tick & t & t & f & t & \dots \\
    \hline
    top & f & f & t & f & \dots \\
    \hline
    o & 1 & 2 & 0 & 1 & \dots \\
    \hline
  \end{array}
  \]
\end{frame}


\begin{frame}
  \frametitle{Exemple 1 : compteur - code MiniLS}

  \footnotesize

  \input{compteur_mls}

  Le code n'est plus formé que d'équations.
\end{frame}

\begin{frame}
  \frametitle{Exemple 1 : compteur - code MiniLS sans reset}

  \footnotesize

  \input{compteur_mls_rless}

  La réinitialisation logique est explicitée via un paramètre du nœud.
\end{frame}

\begin{frame}
  \frametitle{Exemple 1 : compteur - code MiniLS final}

  \footnotesize

  \input{compteur_mls_norm}

  Le code est normalisé et ordonnancé.
\end{frame}

\begin{frame}
  \frametitle{Exemple 1 : compteur - code VHDL}

  \tiny

  \begin{columns}[t]
    \hspace{1cm}
    \begin{column}{6cm}
      \include{compteur_vhdl1}
    \end{column}
    \begin{column}{6cm}
      \include{compteur_vhdl2}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Exemple 1 : compteur - caractéristiques du code VHDL}

  \begin{block}{Simulation comportementale}
    \vspace{0.3cm}
    \begin{center}
      \includegraphics[width=10cm]{capture-chrono-compteur}
    \end{center}
  \end{block}

  \begin{block}{Synthèse}
    L'outil industriel \textit{Xilinx XST} synthétise une netlist avec des
    propriétés satisfaisantes :

    \begin{itemize}
    \item Un additionneur 32 bits pour \textbf{o}.
    \item Un registre 32 bits pour \textbf{h\_v\_26}.
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}
  \frametitle{Exemple 2 : compteur de bits - code original}

  \footnotesize

  \input{autom}
\end{frame}

\begin{frame}
  \frametitle{Exemple 2 : compteur de bits - exemple de sortie attendue}

  Ici, $n = 3$.

  \[
  \begin{array}{r|llllllllllllllllllllllllllll}
    \hline
    x & [t,f,f] & [t,t,t] & [t,t,t] & [t,t,t] & \dots \\
    \hline
    mask & [t,f,t] & [t,f,t] & [t,f,t] & [t,f,t] & \dots \\
    \hline
    sw\_mode & f & t & t & f & \dots \\
    \hline
    o & 1 & 2 & 3 & 3 & \dots \\
    \hline
  \end{array}
  \]
\end{frame}

\begin{frame}
  \frametitle{Exemple 2 : compteur de bits - code MiniLS}

  \tiny

  \begin{columns}[t]
    \hspace{1cm}
    \begin{column}{6cm}
      \include{autom_mls}
    \end{column}
    \begin{column}{6cm}
      \include{autom_mls2}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Exemple 2 : compteur de bits - code MiniLS sans reset}
  \tiny
  \input{autom_mls_rless}
\end{frame}

\begin{frame}
  \frametitle{Exemple 2 : compteur de bits - code MiniLS final}
  \tiny
  \begin{columns}[t]
    \hspace{1cm}
    \begin{column}{6cm}
      \include{autom_mls_norm}
    \end{column}
    \begin{column}{6cm}
      \include{autom_mls_norm2}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Exemple 2 : compteur de bits - code VHDL final}
  \tiny
  \begin{columns}[t]
    \hspace{1cm}
    \begin{column}{6cm}
      \include{autom_vhdl_1}
    \end{column}
    \begin{column}{6cm}
      \include{autom_vhdl_2}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Exemple 2 : compteur de bits - caractéristiques du code VHDL}

  \begin{block}{Simulation comportementale}
    \vspace{0.3cm}
    \begin{center}
      \includegraphics[width=10cm]{capture-chrono-bitcompteur.png}
    \end{center}
  \end{block}

  \begin{block}{Synthèse}
    \textit{Xilinx XST} synthétise une netlist avec des propriétés
    satisfaisantes :

    \begin{itemize}
    \item Deux additionneurs 32 bits.
    \item Un registre 1 bit.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Conclusion}

  \begin{itemize}
  \item Le langage traité est un sous-ensemble de \scadesix{}.
  \item Le prototype est raisonnablement petit.
  \item Les langages intermédiaires data-flow des compilateurs synchrones sont
    un bon point d'entrée pour la génération de code VHDL.
  \end{itemize}
\end{frame}

\end{document}
